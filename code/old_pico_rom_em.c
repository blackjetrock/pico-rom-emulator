////////////////////////////////////////////////////////////////////////////////
//
// Pico ROM Emulator
//
////////////////////////////////////////////////////////////////////////////////


#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/stdlib.h"
//#include "hardware/i2c.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "pico/multicore.h"

#include "f_util.h"

#include "ff.h"
#include "ff_stdio.h"
#include "hw_config.h"
#include "my_debug.h"
#include "rtc.h"
#include "sd_card.h"

// Use this if breakpoints don't work
#define DEBUG_STOP {volatile int x = 1; while(x) {} }

// Are we compiling for the gadget breakout or the picopak?
#define PICOPAK 1

// Drop into a loop that displays key states and does nothing else
#define KEY_DEBUG_ONLY                0

// Interrupts may muck up the pack interface, but it does seem to run with them enabled.
// If USB is ever to work then interrupts need to be enabled.
#define NO_INTERRUPTS_WHILE_POLLING   1
#define TEST_STDIO                    0

//-----------------------------------------------------------------------------
//
// ROM Emulator Flags

// OE pin used to switch data direction
// If 0 then DDIR_A15 used, under processor conrol

#define USE_OE_FOR_DATA_DIRECTION 1

// The address lines we are looking at


#define ROM_SIZE  2*1024
#define ADDRESS_MASK (ROM_SIZE - 1)

// Map from memory space to ROM address space
#define MAP_ROM(X) (X & ADDRESS_MASK)

uint8_t rom_data[ROM_SIZE];

//------------------------------------------------------------------------------

const int D0_PIN = 0;
const int D1_PIN = 1;
const int D2_PIN = 2;
const int D3_PIN = 3;
const int D4_PIN = 4;
const int D5_PIN = 5;
const int D6_PIN = 6;
const int D7_PIN = 7;

//
// The address lines (always inputs)
//
const int  A0_PIN  =  8;
const int  A1_PIN  =  9;
const int  A2_PIN  = 10;
const int  A3_PIN  = 11;
const int  A4_PIN  = 12;
const int  A5_PIN  = 13;
const int  A6_PIN  = 14;
const int  A7_PIN  = 15;
const int  A8_PIN  = 16;
const int  A9_PIN  = 17;
const int  A10_PIN = 18;
const int  A11_PIN = 19;
const int  A12_PIN = 20;
const int  A13_PIN = 21;
const int  A14_PIN = 22;
const int  DDIR_A15_PIN = 26;

const int OE_PIN = 27;
const int CE_PIN = 28;

// Arrays for setting GPIOs up
#define NUM_ADDR 15
#define NUM_DATA 8

const int address_pins[NUM_ADDR] =
  {
   A0_PIN,
   A1_PIN,
   A2_PIN,
   A3_PIN,
   A4_PIN,
   A5_PIN,
   A6_PIN,
   A7_PIN,
   A8_PIN,
   A9_PIN,
   A10_PIN,
   A11_PIN,
   A12_PIN,
   A13_PIN,
   A14_PIN,
   DDIR_A15_PIN,
  };

const int data_pins[NUM_DATA] =
  {
   D0_PIN,
   D1_PIN,
   D2_PIN,
   D3_PIN,
   D4_PIN,
   D5_PIN,
   D6_PIN,
   D7_PIN,
  };

// Redefine pins to match our hardware
#define PICO_SD_CLK_PIN        5
#define PICO_SD_CMD_PIN       18
#define PICO_SD_DAT0_PIN      19
#define ENABLE_4_PIN           0

#define SUPPORT_ID_BYTE        1
#define PAK_ID_BYTE         0x01
#define READ_ONLY              0
#define INIT_PAK_MEMORY        1
#define FF_FIRST_BYTES         0

// Direct access to GPIO registers is faster, and we need speed
#define DIRECT_GPIO            1

// Number of buttons used for the menu system. The 'exit polling' button is not in this
// list, it is coded as a GPIO line as we don't want to waste time processing the menu
// buttons inthe fast polling loop

#define NUM_BUTTONS            3

// All organiser files are in this subdirectory on the SD card, just to keep things tidy
// and allow the card to be used for other things if needed.
#define PAK_DIR                "/PAK"

// Debounce
#define MAX_BUT_COUNT          6

bool sd_ok_flag = false;

// Do we use a polling loop of interrupts?
#define USE_INTERRUPTS         0
#define USE_POLLING            1

// For added speed, we poll the address counter stuff on the other core
#define MULTICORE_POLL         1

// The address into pak memory
#define PAK_ADDRESS (ss_address | ss_page)

// For the OLED display
const uint SDA_PIN             = 29;
const uint SCL_PIN             = 29;

#ifndef I2C_FUNCTIONS_H_
#define I2C_FUNCTIONS_H_

typedef unsigned char BYTE;

// Buttons got changed for PCB layout reasons
#if PICOPAK
const int SW0_PIN       = 0;
const int SW1_PIN       = 1;
const int SW2_PIN       = 5;
const int SW3_PIN       = 26;
#else
const int SW0_PIN       = 0;
const int SW1_PIN       = 1;
const int SW2_PIN       = 26;
const int SW3_PIN       = 5;
#endif

const int SLOT_SPGM_PIN = 2;
const int SLOT_SS_PIN   = 3;
const int SLOT_SCLK_PIN = 4;

const int SLOT_SOE_PIN  = 6;
const int SLOT_SMR_PIN  = 7;

const int SLOT_SD0_PIN  = 8;
const int SLOT_SD1_PIN  = 9;
const int SLOT_SD2_PIN  = 10;
const int SLOT_SD3_PIN  = 11;
const int SLOT_SD4_PIN  = 12;
const int SLOT_SD5_PIN  = 13;
const int SLOT_SD6_PIN  = 14;
const int SLOT_SD7_PIN  = 15;

const int LS_DIR_PIN    = 29;

volatile int ss_count = 0;
volatile int soe_state = 1;
volatile int ss_address = 0;
volatile int ss_page = 0;


// Memory that emulates a pak
typedef unsigned char BYTE;
typedef void (*FPTR)();
typedef void (*CMD_FPTR)(char *cmd);

// The tracing was used for low level analysis of the protocol
#define TRACE_LENGTH 8192
BYTE trace[TRACE_LENGTH];

int trace_i = 0;
//#define TRACE(XX) if(trace_i != (TRACE_LENGTH-1)) {trace[trace_i++] = XX; trace_i %= TRACE_LENGTH;}
#define TRACE(XX)

//#define WRITE_TRAP if( (PAK_ADDRESS + data) == 0)  while(1);

#define WRITE_TRAP

//#define PAK_MEMORY_SIZE  65536
#define PAK_MEMORY_SIZE  32768

// Allow a file to be selected. The file name will be stored for a later 'read' command.

int file_offset = 0;
int max_filenum = 0;

// File names for paks that are written to SD card
#define FILE_PAGE 7
#define PAK_FILE_NAME_FORMAT "pak%05d.opk"
#define PAK_FILE_NAME_GLOB   "pak*.opk"

// I2C Port descriptor
typedef struct _I2C_PORT_DESC
{
  unsigned char sdaport;
  unsigned char sdabit;
  unsigned char sclport;
  unsigned char sclbit;
} I2C_PORT_DESC;


// Slave device descriptor
typedef struct _I2C_SLAVE_DESC
{
  I2C_PORT_DESC *port;             // Port the device is on
  unsigned char slave_7bit_addr;        // SLave address
} I2C_SLAVE_DESC;


#if PICOPAK
#define MENU_MAX  3
#else
#define MENU_MAX  6
#endif

int menu_offset = 0;

typedef struct _BUTTON
{
  int     count;
  bool pressed;
  bool last_pressed;   // For edge detection
  FPTR    event_fn;
} BUTTON;

BUTTON buttons[NUM_BUTTONS];
enum ELEMENT_TYPE
  {
   BUTTON_ELEMENT = 10,
   SUB_MENU,
   MENU_END,
  };

struct MENU_ELEMENT
{
  enum ELEMENT_TYPE type;
  char *text;
  void *submenu;
  void (*function)(struct MENU_ELEMENT *e);
};

void button_display(struct MENU_ELEMENT *e);
void button_list(struct MENU_ELEMENT *e);
//void but_ev_file_up();
//void but_ev_file_down();
void but_ev_file_select();

void loop_delay(int delay)
{
  volatile x, y;

  for(x=0; x<delay; x++)
    {
      for(y=0; y<10; y++)
	{
	}
    }
}

int menuloop_done = 0;

#if !INIT_PAK_MEMORY
volatile BYTE pak_memory[PAK_MEMORY_SIZE];
#else

// Complete 'angling' pack embedded in flash. It is probably possible to store
// evrery known pack in SPI flash and not use the SD card at all. Obviously with no
// SD card there's no saving of packs, though.

BYTE pak_memory[PAK_MEMORY_SIZE] =
  {
   0x78,0x04,0x56,0x00,0x03,0x02,0x35,0x46,0x06,0x4c,
   0x09,0x81,0x4d,0x41,0x49,0x4e,0x20,0x20,0x20,0x20,0x90,0x09,0x83,0x46,0x49,0x53,
   0x48,0x20,0x20,0x20,0x20,0x00,0x02,0x80,0x01,0x26,0x01,0x22,0x00,0x29,0x00,0xfc,
   0x00,0x00,0x13,0x02,0x59,0x25,0x00,0xff,0xe9,0x03,0x44,0x52,0x24,0x02,0xff,0xe6,
   0x02,0x46,0x24,0x02,0xff,0xdc,0x00,0x00,0x00,0x06,0xff,0xe5,0x02,0xff,0xdb,0x08,
   0x00,0x00,0x0f,0xff,0xdc,0x24,0x04,0x46,0x49,0x53,0x48,0x20,0x02,0x20,0x01,0x7d,
   0x06,0x45,0x58,0x49,0x53,0x54,0x24,0x81,0x02,0xff,0xdc,0x24,0x00,0x4a,0x7e,0x00,
   0x32,0x0d,0xff,0xd9,0x24,0x10,0x43,0x52,0x45,0x41,0x54,0x45,0x2d,0x46,0x49,0x4c,
   0x45,0x2c,0x51,0x55,0x49,0x54,0x98,0x7f,0x00,0xff,0xd9,0x022,0x00,0x01,0x2c,0x7e,
   0x00,0x10,0x20,0x00,0x7d,0x06,0x46,0x49,0x53,0x48,0x43,0x52,0x84,0x51,0x00,0x03,
   0x7b,0x20,0x00,0x7d,0x06,0x46,0x49,0x53,0x48,0x4f,0x50,0x84,0x20,0x00,0x7d,0x06,
   0x4d,0x41,0x44,0x55,0x44,0x47,0x84,0x0d,0xff,0xd7,0x24,0x20,0x41,0x44,0x44,0x2d,
   0x4e,0x45,0x57,0x2d,0x46,0x49,0x53,0x48,0x2c,0x53,0x45,0x41,0x52,0x43,0x48,0x2c,
   0x52,0x45,0x50,0x4f,0x52,0x54,0x2c,0x55,0x54,0x49,0x4c,0x53,0x98,0x7f,0x00,0xff,
   0xd7,0x22,0x00,0x01,0x2c,0x7e,0x00,0x14,0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,
   0x41,0x44,0x44,0x84,0x51,0xff,0xc2,0x51,0x00,0x55,0x00,0xff,0xd7,0x22,0x00,0x02,
   0x2c,0x7e,0x00,0x14,0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,0x53,0x45,0x45,0x84,
   0x51,0xff,0xa6,0x51,0x00,0x39,0x00,0xff,0xd7,0x22,0x00,0x03,0x2c,0x7e,0x00,0x14,
   0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,0x52,0x45,0x50,0x84,0x51,0xff,0x8a,0x51,
   0x00,0x1d,0x00,0xff,0xd7,0x22,0x00,0x04,0x2c,0x7e,0x00,0x12,0x20,0x00,0x7d,0x05,
   0x55,0x54,0x49,0x4c,0x53,0x84,0x51,0xff,0x70,0x51,0x00,0x03,0x7b,0x7b,0x00,0x00,
   0x09,0x83,0x46,0x49,0x53,0x48,0x41,0x44,0x44,0x20,0x00,0x02,0x80,0x06,0x11,0x06,
   0x0d,0x00,0x3a,0x05,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xff,0xf4,0x06,0xff,
   0xe6,0x04,0xff,0xe2,0x02,0xff,0xde,0x02,0xff,0xd8,0x04,0xff,0xc6,0x10,0x00,0x00,
   0x4e,0x24,0x0f,0x45,0x58,0x45,0x20,0x74,0x6f,0x20,0x63,0x6f,0x6e,0x74,0x69,0x6e,
   0x75,0x65,0x71,0x73,0x24,0x0d,0x43,0x4c,0x45,0x41,0x52,0x20,0x74,0x6f,0x20,0x71,
   0x75,0x69,0x74,0x71,0x73,0x0d,0xff,0xfc,0x91,0x7f,0x00,0xff,0xfc,0x22,0x00,0x0d,
   0x2b,0x7e,0x00,0x03,0x7b,0x4e,0x62,0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0xb9,
   0x22,0x00,0x10,0xc0,0x81,0x0f,0xff,0xc7,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,
   0x81,0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0x6b,0x24,0x04,0x44,0x41,0x59,0x24,
   0x1c,0x00,0x02,0xff,0xc7,0x49,0x7e,0x00,0x85,0x53,0xff,0xff,0x24,0x04,0x44,0x41,
   0x59,0x24,0x1f,0x00,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,0x22,0x00,0x10,0xc0,
   0x81,0x22,0x00,0x03,0x6a,0x0f,0xff,0xe3,0x8c,0x86,0x22,0x00,0x02,0xbc,0x81,0x0f,
   0xff,0xdf,0x9a,0x86,0x22,0x00,0x02,0xbc,0x81,0x0f,0xff,0xd9,0xa1,0x86,0x22,0x00,
   0x04,0xbc,0x81,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x0f,0xff,0xe3,0x6b,0x22,0x00,
   0x04,0x22,0x00,0x02,0x4c,0x0f,0xff,0xdf,0x6b,0x22,0x00,0x08,0x22,0x00,0x02,0x4c,
   0x0f,0xff,0xd9,0x6b,0x24,0x01,0x44,0x1e,0x00,0x02,0xff,0xe3,0xb5,0x02,0xff,0xdf,
   0xb5,0x22,0x00,0x64,0x86,0x3e,0x3c,0x02,0xff,0xd9,0xb5,0x22,0x27,0x10,0x86,0x3e,
   0x3c,0x80,0x22,0x00,0x01,0x6a,0x53,0x00,0x00,0x51,0x00,0x24,0x24,0x01,0x44,0x1e,
   0x00,0xa1,0x86,0x80,0x24,0x01,0x44,0x1e,0x00,0x24,0x01,0x44,0x1b,0x00,0x22,0x27,
   0x10,0x86,0x3e,0x9a,0x22,0x00,0x64,0x2f,0x86,0x3c,0x8c,0x86,0x3c,0x80,0x4e,0x24,
   0x0c,0x45,0x4e,0x54,0x45,0x52,0x20,0x57,0x41,0x54,0x45,0x52,0x53,0x71,0x73,0x24,
   0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1f,0x00,0x6b,0x24,0x06,0x57,0x41,0x54,0x45,
   0x52,0x24,0x1f,0x00,0x24,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1c,0x00,0xc7,0x81,
   0x4e,0x0d,0xff,0xfc,0x24,0x22,0x53,0x41,0x4c,0x4d,0x4f,0x4e,0x2c,0x53,0x45,0x41,
   0x2d,0x54,0x52,0x4f,0x55,0x54,0x2c,0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,0x4f,
   0x55,0x54,0x2c,0x4f,0x54,0x48,0x45,0x52,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,
   0x2c,0x7e,0x00,0x17,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x06,0x53,
   0x41,0x4c,0x4d,0x4f,0x4e,0x81,0x51,0x00,0x85,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,
   0x7e,0x00,0x1a,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x09,0x53,0x45,
   0x41,0x2d,0x54,0x52,0x4f,0x55,0x54,0x81,0x51,0x00,0x63,0x00,0xff,0xfc,0x22,0x00,
   0x03,0x2c,0x7e,0x00,0x1c,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x0b,
   0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,0x4f,0x55,0x54,0x81,0x51,0x00,0x3f,0x00,
   0xff,0xfc,0x22,0x00,0x04,0x2c,0x7e,0x00,0x32,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,
   0x52,0x20,0x46,0x49,0x53,0x48,0x71,0x73,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,
   0x00,0x6b,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x05,0x46,0x49,0x53,
   0x48,0x24,0x1c,0x00,0xc7,0x81,0x51,0x00,0x05,0x51,0x03,0xc2,0x4e,0x24,0x1c,0x45,
   0x4e,0x54,0x45,0x52,0x20,0x4e,0x55,0x4d,0x42,0x45,0x52,0x20,0x4f,0x46,0x20,0x46,
   0x49,0x53,0x48,0x20,0x43,0x41,0x55,0x47,0x48,0x54,0x20,0x71,0x0f,0xff,0xe7,0x24,
   0x01,0x31,0x81,0x22,0x00,0x03,0x6a,0x0f,0xff,0xe7,0x6b,0x02,0xff,0xe7,0x24,0x00,
   0x4a,0x7e,0x00,0x09,0x0f,0xff,0xe7,0x24,0x01,0x30,0x81,0x53,0xff,0xc0,0x24,0x03,
   0x4e,0x4f,0x25,0x1d,0x00,0x02,0xff,0xe7,0xb5,0x94,0x7f,0x53,0x00,0x00,0x4e,0x22,
   0x00,0x01,0x6a,0x0d,0xff,0xfc,0x24,0x08,0x46,0x4c,0x59,0x2c,0x42,0x41,0x49,0x54,
   0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x60,0x4e,0x24,0x09,0x45,
   0x4e,0x54,0x45,0x52,0x20,0x46,0x4c,0x59,0x71,0x73,0x24,0x04,0x46,0x4c,0x59,0x24,
   0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x13,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,
   0x24,0x06,0x4e,0x4f,0x20,0x46,0x4c,0x59,0x81,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,
   0x00,0x6b,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,0x24,0x04,0x46,0x4c,0x59,0x24,
   0x1c,0x00,0xc7,0x81,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x24,0x07,0x4e,
   0x4f,0x20,0x42,0x41,0x49,0x54,0x81,0x51,0x00,0x72,0x00,0xff,0xfc,0x22,0x00,0x02,
   0x2c,0x7e,0x00,0x65,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,0x52,0x20,0x42,0x41,0x49,
   0x54,0x71,0x73,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,
   0x00,0x15,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x24,0x07,0x4e,0x4f,0x20,
   0x42,0x41,0x49,0x54,0x81,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x6b,0x24,
   0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,
   0x00,0xc7,0x81,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,0x24,0x06,0x4e,0x4f,0x20,
   0x46,0x4c,0x59,0x81,0x51,0x00,0x05,0x51,0x02,0x84,0x4e,0x24,0x0c,0x45,0x4e,0x54,
   0x45,0x52,0x20,0x57,0x45,0x49,0x47,0x48,0x54,0x71,0x73,0x22,0x00,0x03,0x6a,0x22,
   0x00,0x01,0x22,0x00,0x02,0x4c,0x53,0xff,0xe3,0x0f,0xff,0xf5,0x6e,0x02,0xff,0xf5,
   0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xf5,0x24,0x01,0x30,0x81,0x24,0x02,0x57,
   0x54,0x1e,0x00,0x02,0xff,0xf5,0xb5,0x80,0x53,0x00,0x00,0x4e,0x22,0x00,0x01,0x6a,
   0x0d,0xff,0xfc,0x24,0x20,0x43,0x4c,0x4f,0x55,0x44,0x59,0x2c,0x42,0x52,0x49,0x47,
   0x48,0x54,0x2c,0x52,0x41,0x49,0x4e,0x2c,0x54,0x48,0x55,0x4e,0x44,0x45,0x52,0x2c,
   0x4f,0x54,0x48,0x45,0x52,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x17,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x06,0x43,0x4c,0x4f,0x55,
   0x44,0x59,0x81,0x51,0x00,0x9e,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x17,
   0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x06,0x42,0x52,0x49,0x47,0x48,
   0x54,0x81,0x51,0x00,0x7f,0x00,0xff,0xfc,0x22,0x00,0x03,0x2c,0x7e,0x00,0x15,0x24,
   0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x04,0x52,0x41,0x49,0x4e,0x81,0x51,
   0x00,0x62,0x00,0xff,0xfc,0x22,0x00,0x04,0x2c,0x7e,0x00,0x18,0x24,0x05,0x43,0x4f,
   0x4e,0x44,0x24,0x1f,0x00,0x24,0x07,0x54,0x48,0x55,0x4e,0x44,0x45,0x52,0x81,0x51,
   0x00,0x42,0x00,0xff,0xfc,0x22,0x00,0x05,0x2c,0x7e,0x00,0x35,0x4e,0x24,0x0d,0x45,
   0x4e,0x54,0x45,0x52,0x20,0x57,0x45,0x41,0x54,0x48,0x45,0x52,0x71,0x73,0x24,0x05,
   0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x6b,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,
   0x00,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1c,0x00,0xc7,0x81,0x51,0x00,0x05,0x51,
   0x01,0x5c,0x4e,0x0d,0xff,0xfc,0x24,0x1d,0x4e,0x4f,0x4e,0x45,0x2c,0x48,0x49,0x2d,
   0x54,0x49,0x44,0x45,0x2c,0x4d,0x49,0x44,0x2d,0x54,0x49,0x44,0x45,0x2c,0x4c,0x4f,
   0x2d,0x54,0x49,0x44,0x45,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x18,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x07,0x4e,0x4f,0x20,0x54,
   0x49,0x44,0x45,0x81,0x51,0x00,0x69,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,
   0x1a,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x09,0x48,0x49,0x47,0x48,
   0x2d,0x54,0x49,0x44,0x45,0x81,0x51,0x00,0x47,0x00,0xff,0xfc,0x22,0x00,0x03,0x2c,
   0x7e,0x00,0x19,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x08,0x4d,0x49,
   0x44,0x2d,0x54,0x49,0x44,0x45,0x81,0x51,0x00,0x26,0x00,0xff,0xfc,0x22,0x00,0x04,
   0x2c,0x7e,0x00,0x19,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x08,0x4c,
   0x4f,0x57,0x2d,0x54,0x49,0x44,0x45,0x81,0x51,0x00,0x05,0x51,0x00,0xb0,0x4e,0x0d,
   0xff,0xfc,0x24,0x10,0x41,0x4d,0x2c,0x50,0x4d,0x2c,0x4e,0x4f,0x4f,0x4e,0x2c,0x4e,
   0x49,0x47,0x48,0x54,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x13,
   0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,0x02,0x41,0x4d,0x81,0x51,0x00,
   0x5b,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x13,0x24,0x05,0x54,0x49,0x4d,
   0x45,0x24,0x1f,0x00,0x24,0x02,0x50,0x4d,0x81,0x51,0x00,0x40,0x00,0xff,0xfc,0x22,
   0x00,0x03,0x2c,0x7e,0x00,0x15,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,
   0x04,0x4e,0x4f,0x4f,0x4e,0x81,0x51,0x00,0x23,0x00,0xff,0xfc,0x22,0x00,0x04,0x2c,
   0x7e,0x00,0x16,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,0x05,0x4e,0x49,
   0x47,0x48,0x54,0x81,0x51,0x00,0x05,0x51,0x00,0x24,0x4e,0x24,0x0e,0x45,0x4e,0x54,
   0x45,0x52,0x20,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x53,0x71,0x73,0x24,0x08,0x43,
   0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x24,0x1f,0x00,0x6e,0x5b,0x7b,0x4e,0x0d,0xff,0xfc,
   0x24,0x0a,0x53,0x41,0x56,0x45,0x2c,0x41,0x42,0x4f,0x52,0x54,0x98,0x7f,0x00,0xff,
   0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x06,0x5b,0x51,0x00,0x03,0x7b,0x7b,0x00,0x00,
   0x09,0x83,0x46,0x49,0x53,0x48,0x53,0x45,0x45,0x20,0x00,0x02,0x80,0x05,0x0e,0x05,
   0x0a,0x00,0x32,0x04,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xea,0x10,0xff,
   0xd0,0x10,0x00,0x00,0x22,0x00,0x01,0x6a,0x4e,0x0d,0xff,0xe4,0x24,0x18,0x46,0x49,
   0x4e,0x44,0x2c,0x45,0x44,0x49,0x54,0x2c,0x4e,0x4f,0x2e,0x2d,0x4f,0x46,0x2d,0x52,
   0x45,0x43,0x4f,0x52,0x44,0x53,0x98,0x7f,0x00,0xff,0xe4,0x22,0x00,0x01,0x2c,0x7e,
   0x00,0x0c,0x0d,0xff,0xe2,0x22,0x00,0x00,0x7f,0x51,0x00,0x45,0x00,0xff,0xe4,0x22,
   0x00,0x02,0x2c,0x7e,0x00,0x0c,0x0d,0xff,0xe2,0x22,0x00,0x01,0x7f,0x51,0x00,0x31,
   0x00,0xff,0xe4,0x22,0x00,0x03,0x2c,0x7e,0x00,0x26,0x4e,0x24,0x0f,0x4e,0x4f,0x2e,
   0x20,0x4f,0x46,0x20,0x52,0x45,0x43,0x4f,0x52,0x44,0x53,0x3d,0x71,0x73,0x0d,0xff,
   0xe4,0xa2,0x7f,0xa2,0x6f,0x73,0x91,0x83,0x51,0xff,0x8b,0x51,0x00,0x03,0x7b,0x61,
   0x24,0x06,0x46,0x49,0x4e,0x44,0x3a,0x20,0x71,0x73,0x0d,0xff,0xe6,0x95,0x7f,0x0f,
   0xff,0xeb,0x6e,0x00,0xff,0xe6,0x22,0x00,0x01,0x2c,0x7e,0x00,0x03,0x7b,0x0d,0xff,
   0xfc,0x22,0x00,0x00,0x7f,0x0d,0xff,0xfc,0x02,0xff,0xeb,0x8f,0x7f,0x00,0xff,0xfc,
   0x22,0x00,0x00,0x2c,0x7e,0x00,0x1b,0x4e,0x24,0x0f,0x2a,0x2a,0x45,0x4e,0x44,0x20,
   0x4f,0x46,0x20,0x46,0x49,0x4c,0x45,0x2a,0x2a,0x71,0x73,0x91,0x83,0x51,0xff,0x36,
   0x00,0xff,0xe2,0x22,0x00,0x01,0x2c,0x7e,0x00,0x05,0x51,0x00,0x62,0x4e,0xa3,0x7e,
   0x00,0x1a,0x24,0x0f,0x2a,0x2a,0x45,0x4e,0x44,0x20,0x4f,0x46,0x20,0x46,0x49,0x4c,
   0x45,0x2a,0x2a,0x71,0x73,0x91,0x83,0x51,0xff,0x0c,0x0d,0xff,0xe8,0x22,0x00,0x01,
   0x32,0x24,0x00,0x8d,0x7f,0x00,0xff,0xe8,0x22,0x00,0x0d,0x2b,0x7e,0x00,0x1c,0x0d,
   0xff,0xe8,0x22,0x00,0x00,0x24,0x00,0x8d,0x7f,0x00,0xff,0xe8,0x22,0x00,0x01,0x2c,
   0x7e,0x00,0x05,0x51,0x00,0x05,0x51,0xff,0xde,0x00,0xff,0xe8,0x22,0x00,0x01,0x2c,
   0x7e,0x00,0x08,0x51,0xfe,0xd0,0x51,0x00,0x06,0x63,0x51,0xff,0x6a,0x4e,0x22,0x00,
   0x01,0x22,0x00,0x01,0x4c,0x24,0x07,0x45,0x44,0x3a,0x44,0x41,0x54,0x45,0x71,0x73,
   0x0f,0xff,0xd1,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,0x81,0x22,0x00,0x01,0x22,
   0x00,0x02,0x4c,0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0x6b,0x24,0x04,0x44,0x41,
   0x59,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfe,0x89,0x24,0x04,0x44,
   0x41,0x59,0x24,0x1c,0x00,0x02,0xff,0xd1,0x49,0x7e,0x00,0x60,0x4e,0x24,0x0f,0x45,
   0x44,0x3a,0x28,0x79,0x79,0x79,0x79,0x20,0x6d,0x6d,0x20,0x64,0x64,0x29,0x71,0x73,
   0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,
   0x22,0x00,0x10,0xc0,0x81,0x53,0xff,0xd6,0x22,0x00,0x03,0x6a,0x0f,0xff,0xd1,0x24,
   0x01,0x44,0x1b,0x00,0x22,0x00,0x08,0xbc,0x81,0x0f,0xff,0xd1,0x6b,0x02,0xff,0xd1,
   0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfe,0x2d,0x24,0x01,0x44,0x1e,0x00,0x02,0xff,
   0xd1,0xb5,0x80,0x22,0x00,0x01,0x6a,0x53,0x00,0x00,0x4e,0x24,0x09,0x45,0x44,0x3a,
   0x57,0x41,0x54,0x45,0x52,0x53,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,
   0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1f,0x00,0x6b,0x24,0x06,0x57,0x41,0x54,0x45,
   0x52,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfd,0xe9,0x24,0x06,0x57,
   0x41,0x54,0x45,0x52,0x24,0x1f,0x00,0x24,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1c,
   0x00,0xc7,0x81,0x4e,0x24,0x07,0x45,0x44,0x3a,0x46,0x49,0x53,0x48,0x71,0x73,0x22,
   0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x6b,
   0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,
   0xfd,0xa4,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x05,0x46,0x49,0x53,
   0x48,0x24,0x1c,0x00,0xc7,0x81,0x0f,0xff,0xd1,0x24,0x03,0x4e,0x4f,0x25,0x1a,0x00,
   0x86,0x22,0x00,0x06,0xbc,0x81,0x4e,0x24,0x0e,0x45,0x44,0x3a,0x4e,0x4f,0x2e,0x20,
   0x4f,0x46,0x20,0x46,0x49,0x53,0x48,0x71,0x73,0x53,0xff,0xec,0x22,0x00,0x03,0x6a,
   0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x04,0x4e,0x4f,0x3a,0x20,0x71,0x73,0x22,
   0x00,0x05,0x22,0x00,0x02,0x4c,0x0f,0xff,0xd1,0x6b,0x02,0xff,0xd1,0x24,0x00,0x4a,
   0x7e,0x00,0x05,0x51,0xfd,0x40,0x24,0x03,0x4e,0x4f,0x25,0x1d,0x00,0x02,0xff,0xd1,
   0xb5,0x87,0x7f,0x53,0x00,0x00,0x0f,0xff,0xd1,0x24,0x02,0x57,0x54,0x1b,0x00,0x22,
   0x00,0x08,0xbc,0x81,0x4e,0x24,0x09,0x45,0x44,0x3a,0x57,0x45,0x49,0x47,0x48,0x54,
   0x71,0x73,0x53,0xff,0xf1,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x04,0x57,0x54,
   0x3a,0x20,0x71,0x73,0x22,0x00,0x05,0x22,0x00,0x02,0x4c,0x0f,0xff,0xd1,0x6b,0x02,
   0xff,0xd1,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfc,0xeb,0x24,0x02,0x57,0x54,0x1e,
   0x00,0x02,0xff,0xd1,0xb5,0x80,0x22,0x00,0x01,0x6a,0x53,0x00,0x00,0x4e,0x24,0x06,
   0x45,0x44,0x3a,0x46,0x4c,0x59,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,
   0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,0x6b,0x24,0x04,0x46,0x4c,0x59,0x24,0x1c,0x00,
   0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfc,0xad,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,
   0x00,0x24,0x04,0x46,0x4c,0x59,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,0x07,0x45,0x44,
   0x3a,0x42,0x41,0x49,0x54,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,
   0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x6b,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,
   0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfc,0x6c,0x24,0x05,0x42,0x41,0x49,0x54,
   0x24,0x1f,0x00,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,
   0x0e,0x45,0x44,0x3a,0x54,0x49,0x4d,0x45,0x20,0x4f,0x46,0x20,0x44,0x41,0x59,0x71,
   0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,
   0x00,0x6b,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,
   0x05,0x51,0xfc,0x22,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,0x05,0x54,
   0x49,0x4d,0x45,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,0x07,0x45,0x44,0x3a,0x54,0x49,
   0x44,0x45,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,0x54,0x49,0x44,
   0x45,0x24,0x1f,0x00,0x6b,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1c,0x00,0x24,0x00,
   0x4a,0x7e,0x00,0x05,0x51,0xfb,0xdf,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,
   0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,0x0a,0x45,0x44,
   0x3a,0x57,0x45,0x41,0x54,0x48,0x45,0x52,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,
   0x4c,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x6b,0x24,0x05,0x43,0x4f,0x4e,
   0x44,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfb,0x99,0x24,0x05,0x43,
   0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1c,0x00,0xc7,
   0x81,0x4e,0x4e,0x24,0x0a,0x45,0x44,0x3a,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x71,
   0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x08,0x43,0x4f,0x4d,0x4d,0x45,0x4e,
   0x54,0x24,0x1f,0x00,0x6b,0x4e,0x0d,0xff,0xce,0x24,0x17,0x53,0x41,0x56,0x45,0x2c,
   0x49,0x47,0x4e,0x4f,0x52,0x45,0x2c,0x44,0x45,0x4c,0x45,0x54,0x45,0x2c,0x51,0x55,
   0x49,0x54,0x98,0x7f,0x00,0xff,0xce,0x22,0x00,0x01,0x2c,0x7e,0x00,0x09,0x68,0x51,
   0xfb,0x34,0x51,0x00,0x27,0x00,0xff,0xce,0x22,0x00,0x02,0x2c,0x7e,0x00,0x09,0x63,
   0x51,0xfb,0xc4,0x51,0x00,0x16,0x00,0xff,0xce,0x22,0x00,0x03,0x2c,0x7e,0x00,0x09,
   0x60,0x51,0xfb,0x12,0x51,0x00,0x05,0x51,0xfb,0x0c,0x7b,0x00,0x00,0x09,0x83,0x46,
   0x49,0x53,0x48,0x43,0x52,0x20,0x20,0x00,0x02,0x80,0x00,0xb7,0x00,0xb3,0x00,0x06,
   0x00,0xa1,0x00,0x00,0x00,0x00,0x05,0x03,0x44,0x52,0x24,0x02,0x00,0x00,0x00,0x00,
   0x0d,0xff,0xfa,0x20,0x00,0x7d,0x06,0x50,0x41,0x43,0x4b,0x49,0x4e,0x87,0x7f,0x00,
   0xff,0xfa,0x22,0x00,0x00,0x2c,0x7e,0x00,0x03,0x7b,0x09,0xff,0xfc,0x24,0x04,0x46,
   0x49,0x53,0x48,0x4b,0x5e,0x00,0x02,0x04,0x44,0x41,0x59,0x24,0x02,0x06,0x57,0x41,
   0x54,0x45,0x52,0x24,0x02,0x05,0x46,0x49,0x53,0x48,0x24,0x00,0x03,0x4e,0x4f,0x25,
   0x01,0x02,0x57,0x54,0x02,0x04,0x46,0x4c,0x59,0x24,0x02,0x05,0x42,0x41,0x49,0x54,
   0x24,0x02,0x05,0x54,0x49,0x4d,0x45,0x24,0x02,0x05,0x54,0x49,0x44,0x45,0x24,0x02,
   0x05,0x43,0x4f,0x4e,0x44,0x24,0x02,0x08,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x24,
   0x01,0x01,0x44,0x88,0x4e,0x24,0x0e,0x46,0x49,0x53,0x48,0x20,0x46,0x49,0x4c,0x45,
   0x20,0x4d,0x41,0x44,0x45,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x04,0x4f,0x4e,0x20,
   0x20,0x71,0x09,0xff,0xfc,0x71,0x24,0x06,0x20,0x44,0x52,0x49,0x56,0x45,0x71,0x73,
   0x7b,0x00,0x00,0x09,0x83,0x46,0x49,0x53,0x48,0x4f,0x50,0x20,0x20,0x00,0x02,0x80,
   0x00,0x6a,0x00,0x66,0x00,0x04,0x00,0x55,0x00,0x00,0x00,0x00,0x04,0x02,0x46,0x24,
   0x02,0x00,0x00,0x00,0x00,0x09,0xff,0xfc,0x5a,0x65,0x00,0x02,0x04,0x44,0x41,0x59,
   0x24,0x02,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x02,0x05,0x46,0x49,0x53,0x48,0x24,
   0x00,0x03,0x4e,0x4f,0x25,0x01,0x02,0x57,0x54,0x02,0x04,0x46,0x4c,0x59,0x24,0x02,
   0x05,0x42,0x41,0x49,0x54,0x24,0x02,0x05,0x54,0x49,0x4d,0x45,0x24,0x02,0x05,0x54,
   0x49,0x44,0x45,0x24,0x02,0x05,0x43,0x4f,0x4e,0x44,0x24,0x02,0x08,0x43,0x4f,0x4d,
   0x4d,0x45,0x4e,0x54,0x24,0x01,0x01,0x44,0x88,0x7b,0x00,0x00,0x09,0x83,0x46,0x49,
   0x53,0x48,0x52,0x45,0x50,0x20,0x00,0x02,0x80,0x0a,0x9a,0x0a,0x96,0x02,0x9b,0x0a,
   0x45,0x00,0x00,0x24,0x02,0x52,0x24,0x05,0xfe,0x6d,0x02,0x43,0x25,0x00,0xfe,0x6a,
   0x03,0x42,0x49,0x47,0x01,0xfe,0x62,0x05,0x42,0x44,0x41,0x59,0x24,0x02,0xfe,0x51,
   0x04,0x43,0x4f,0x4d,0x24,0x02,0xfe,0x3f,0x00,0x00,0x00,0x18,0xfe,0x6c,0x20,0xfe,
   0x50,0x10,0xfe,0x3e,0x10,0xfe,0x1e,0x02,0xfe,0x1a,0x02,0xfe,0x14,0x04,0xfd,0x89,
   0x10,0xfd,0x65,0x20,0x00,0x08,0xfe,0x6d,0x00,0x0b,0xfd,0x8a,0x00,0x08,0x4e,0x0d,
   0xfe,0x32,0x24,0x10,0x46,0x49,0x53,0x48,0x49,0x4e,0x47,0x20,0x52,0x45,0x53,0x55,
   0x4c,0x54,0x53,0x3a,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2b,0x7e,0x00,0x03,
   0x7b,0x22,0x00,0x03,0x6a,0x53,0xff,0xff,0x4e,0x24,0x08,0x46,0x52,0x4f,0x4d,0x20,
   0x64,0x64,0x20,0x71,0x73,0x22,0x00,0x06,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x1f,0x6e,
   0x02,0xfe,0x1f,0x24,0x00,0x4a,0x7e,0x00,0x22,0x0e,0xfe,0x2a,0x22,0x00,0x00,0x86,
   0x80,0x0f,0xfd,0x66,0x24,0x0f,0x46,0x52,0x4f,0x4d,0x3a,0x20,0x42,0x45,0x47,0x49,
   0x4e,0x4e,0x49,0x4e,0x47,0x81,0x51,0x00,0x72,0x22,0x00,0x09,0x22,0x00,0x01,0x4c,
   0x24,0x02,0x6d,0x6d,0x71,0x73,0x22,0x00,0x09,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x1b,
   0x6e,0x22,0x00,0x0c,0x22,0x00,0x01,0x4c,0x24,0x04,0x79,0x79,0x79,0x79,0x71,0x73,
   0x22,0x00,0x0c,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x15,0x6e,0x0e,0xfe,0x2a,0x02,0xfe,
   0x1f,0xb5,0x02,0xfe,0x1b,0xb5,0x22,0x00,0x64,0x86,0x3e,0x3c,0x02,0xfe,0x15,0xb5,
   0x22,0x27,0x10,0x86,0x3e,0x3c,0x80,0x0f,0xfd,0x66,0x24,0x05,0x46,0x52,0x4f,0x4d,
   0x3a,0x02,0xfe,0x15,0x4b,0x24,0x01,0x2f,0x4b,0x02,0xfe,0x1b,0x4b,0x24,0x01,0x2f,
   0x4b,0x02,0xfe,0x1f,0x4b,0x81,0x53,0x00,0x00,0x53,0x00,0x00,0x53,0xff,0xfc,0x4e,
   0x24,0x08,0x20,0x54,0x4f,0x20,0x20,0x64,0x64,0x20,0x71,0x73,0x22,0x00,0x06,0x22,
   0x00,0x02,0x4c,0x0f,0xfe,0x1f,0x6e,0x02,0xfe,0x1f,0x24,0x00,0x4a,0x02,0xfe,0x1f,
   0x24,0x03,0x41,0x4c,0x4c,0x4a,0x35,0x7e,0x00,0x29,0x0e,0xfe,0x22,0x23,0x05,0x99,
   0x99,0x99,0x99,0x07,0x80,0x0f,0xfd,0x66,0x02,0xfd,0x66,0x24,0x0f,0x20,0x54,0x4f,
   0x3a,0x45,0x4e,0x44,0x20,0x4f,0x46,0x20,0x46,0x49,0x4c,0x45,0x4b,0x81,0x51,0x00,
   0x76,0x22,0x00,0x09,0x22,0x00,0x01,0x4c,0x24,0x02,0x6d,0x6d,0x71,0x73,0x22,0x00,
   0x09,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x1b,0x6e,0x22,0x00,0x0c,0x22,0x00,0x01,0x4c,
   0x24,0x04,0x79,0x79,0x79,0x79,0x71,0x73,0x22,0x00,0x0c,0x22,0x00,0x02,0x4c,0x0f,
   0xfe,0x15,0x6e,0x0e,0xfe,0x22,0x02,0xfe,0x1f,0xb5,0x02,0xfe,0x1b,0xb5,0x22,0x00,
   0x64,0x86,0x3e,0x3c,0x02,0xfe,0x15,0xb5,0x22,0x27,0x10,0x86,0x3e,0x3c,0x80,0x0f,
   0xfd,0x66,0x02,0xfd,0x66,0x24,0x05,0x20,0x20,0x54,0x4f,0x3a,0x4b,0x02,0xfe,0x15,
   0x4b,0x24,0x01,0x2f,0x4b,0x02,0xfe,0x1b,0x4b,0x24,0x01,0x2f,0x4b,0x02,0xfe,0x1f,
   0x4b,0x81,0x53,0x00,0x00,0x53,0x00,0x00,0x22,0x00,0x01,0x6a,0x0d,0xfd,0x87,0x22,
   0x00,0x01,0x7f,0x4e,0x24,0x0c,0x45,0x4e,0x54,0x45,0x52,0x20,0x57,0x41,0x54,0x45,
   0x52,0x53,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x00,0xfd,0x87,0x05,0xfd,
   0x8a,0x24,0x00,0x4a,0x00,0xfd,0x87,0x05,0xfd,0x8a,0x24,0x03,0x41,0x4c,0x4c,0x4a,
   0x35,0x7e,0x00,0x0b,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x0d,0xfd,0x87,
   0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,0x32,0x24,0x26,0x41,0x4c,0x4c,
   0x2c,0x53,0x41,0x4c,0x4d,0x4f,0x4e,0x2c,0x53,0x45,0x41,0x2d,0x54,0x52,0x4f,0x55,
   0x54,0x2c,0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,0x4f,0x55,0x54,0x2c,0x4f,0x54,
   0x48,0x45,0x52,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,0x0e,0x00,
   0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0x90,0x00,0xfe,0x32,0x22,0x00,
   0x02,0x2c,0x7e,0x00,0x14,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x06,0x53,0x41,0x4c,
   0x4d,0x4f,0x4e,0x81,0x51,0x00,0x74,0x00,0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,
   0x17,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x09,0x53,0x45,0x41,0x2d,0x54,0x52,0x4f,
   0x55,0x54,0x81,0x51,0x00,0x55,0x00,0xfe,0x32,0x22,0x00,0x04,0x2c,0x7e,0x00,0x19,
   0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x0b,0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,
   0x4f,0x55,0x54,0x81,0x51,0x00,0x34,0x00,0xfe,0x32,0x22,0x00,0x05,0x2c,0x7e,0x00,
   0x29,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,0x52,0x20,0x46,0x49,0x53,0x48,0x71,0x73,
   0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x00,0xfd,0x87,
   0x05,0xfd,0x8a,0xc7,0x81,0x51,0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,
   0x00,0x01,0x2d,0x7f,0x0d,0xfe,0x32,0x24,0x0c,0x41,0x4c,0x4c,0x2c,0x46,0x4c,0x59,
   0x2c,0x42,0x41,0x49,0x54,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x0e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0x48,0x00,0xfe,0x32,
   0x22,0x00,0x02,0x2c,0x7e,0x00,0x1a,0x4e,0x24,0x09,0x45,0x4e,0x54,0x45,0x52,0x20,
   0x46,0x4c,0x59,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x51,0x00,0x26,0x00,
   0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,0x1b,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,
   0x52,0x20,0x42,0x41,0x49,0x54,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x51,
   0x00,0x03,0x7b,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x00,0xfd,0x87,0x05,0xfd,0x8a,0xc7,
   0x81,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,0x32,0x24,
   0x14,0x41,0x4c,0x4c,0x2c,0x41,0x4d,0x2c,0x50,0x4d,0x2c,0x4e,0x4f,0x4f,0x4e,0x2c,
   0x4e,0x49,0x47,0x48,0x54,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x0e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0x68,0x00,0xfe,0x32,
   0x22,0x00,0x02,0x2c,0x7e,0x00,0x10,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x02,0x41,
   0x4d,0x81,0x51,0x00,0x50,0x00,0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,0x10,0x00,
   0xfd,0x87,0x12,0xfd,0x8a,0x24,0x02,0x50,0x4d,0x81,0x51,0x00,0x38,0x00,0xfe,0x32,
   0x22,0x00,0x04,0x2c,0x7e,0x00,0x12,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x04,0x4e,
   0x4f,0x4f,0x4e,0x81,0x51,0x00,0x1e,0x00,0xfe,0x32,0x22,0x00,0x05,0x2c,0x7e,0x00,
   0x13,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x05,0x4e,0x49,0x47,0x48,0x54,0x81,0x51,
   0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,
   0x32,0x24,0x1c,0x41,0x4c,0x4c,0x2c,0x48,0x49,0x2d,0x54,0x49,0x44,0x45,0x2c,0x4d,
   0x49,0x44,0x2d,0x54,0x49,0x44,0x45,0x2c,0x4c,0x4f,0x2d,0x54,0x49,0x44,0x45,0x98,
   0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,0x0e,0x00,0xfd,0x87,0x12,0xfd,
   0x8a,0x24,0x00,0x81,0x51,0x00,0x5e,0x00,0xfe,0x32,0x22,0x00,0x02,0x2c,0x7e,0x00,
   0x17,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x09,0x48,0x49,0x47,0x48,0x2d,0x54,0x49,
   0x44,0x45,0x81,0x51,0x00,0x3f,0x00,0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,0x16,
   0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x08,0x4d,0x49,0x44,0x2d,0x54,0x49,0x44,0x45,
   0x81,0x51,0x00,0x21,0x00,0xfe,0x32,0x22,0x00,0x04,0x2c,0x7e,0x00,0x16,0x00,0xfd,
   0x87,0x12,0xfd,0x8a,0x24,0x08,0x4c,0x4f,0x57,0x2d,0x54,0x49,0x44,0x45,0x81,0x51,
   0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,
   0x32,0x24,0x24,0x41,0x4c,0x4c,0x2c,0x43,0x4c,0x4f,0x55,0x44,0x59,0x2c,0x42,0x52,
   0x49,0x47,0x48,0x54,0x2c,0x52,0x41,0x49,0x4e,0x2c,0x54,0x48,0x55,0x4e,0x44,0x45,
   0x52,0x2c,0x4f,0x54,0x48,0x45,0x52,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,
   0x7e,0x00,0x0e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0xa6,0x00,
   0xfe,0x32,0x22,0x00,0x02,0x2c,0x7e,0x00,0x14,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,
   0x06,0x43,0x4c,0x4f,0x55,0x44,0x59,0x81,0x51,0x00,0x8a,0x00,0xfe,0x32,0x22,0x00,
   0x03,0x2c,0x7e,0x00,0x14,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x06,0x42,0x52,0x49,
   0x47,0x48,0x54,0x81,0x51,0x00,0x6e,0x00,0xfe,0x32,0x22,0x00,0x04,0x2c,0x7e,0x00,
   0x12,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x04,0x52,0x41,0x49,0x4e,0x81,0x51,0x00,
   0x54,0x00,0xfe,0x32,0x22,0x00,0x05,0x2c,0x7e,0x00,0x15,0x00,0xfd,0x87,0x12,0xfd,
   0x8a,0x24,0x07,0x54,0x48,0x55,0x4e,0x44,0x45,0x52,0x81,0x51,0x00,0x37,0x00,0xfe,
   0x32,0x22,0x00,0x06,0x2c,0x7e,0x00,0x2c,0x4e,0x24,0x0d,0x45,0x4e,0x54,0x45,0x52,
   0x20,0x57,0x45,0x41,0x54,0x48,0x45,0x52,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,
   0x6e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x00,0xfd,0x87,0x05,0xfd,0x8a,0xc7,0x81,0x51,
   0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x4e,0x24,
   0x0b,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x20,0x3d,0x20,0x3f,0x71,0x73,0x00,0xfd,
   0x87,0x12,0xfd,0x8a,0x6e,0x4e,0x24,0x10,0x50,0x6c,0x65,0x61,0x73,0x65,0x20,0x77,
   0x61,0x69,0x74,0x2e,0x2e,0x2e,0x2e,0x2e,0x71,0x73,0x61,0x0d,0xfe,0x3c,0x22,0x00,
   0x00,0x7f,0x0e,0xfe,0x34,0x22,0x00,0x00,0x86,0x80,0x0e,0xfe,0x62,0x22,0x00,0x00,
   0x86,0x80,0x0f,0xfe,0x51,0x24,0x00,0x81,0xa3,0x33,0x7e,0x01,0x40,0x24,0x01,0x44,
   0x1b,0x00,0x01,0xfe,0x2a,0x39,0x24,0x01,0x44,0x1b,0x00,0x01,0xfe,0x22,0x37,0x34,
   0x7e,0x01,0x26,0x24,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1c,0x00,0x22,0x00,0x01,
   0x05,0xfd,0x8a,0x4a,0x22,0x00,0x01,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x7e,0x01,
   0x08,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1c,0x00,0x22,0x00,0x02,0x05,0xfd,0x8a,
   0x4a,0x22,0x00,0x02,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x7e,0x00,0xeb,0x24,0x04,
   0x46,0x4c,0x59,0x24,0x1c,0x00,0x22,0x00,0x03,0x05,0xfd,0x8a,0x4a,0x24,0x05,0x42,
   0x41,0x49,0x54,0x24,0x1c,0x00,0x22,0x00,0x03,0x05,0xfd,0x8a,0x4a,0x35,0x22,0x00,
   0x03,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x7e,0x00,0xbe,0x24,0x05,0x54,0x49,0x4d,
   0x45,0x24,0x1c,0x00,0x22,0x00,0x04,0x05,0xfd,0x8a,0x4a,0x22,0x00,0x04,0x05,0xfd,
   0x8a,0x24,0x00,0x4a,0x35,0x7e,0x00,0xa1,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1c,
   0x00,0x22,0x00,0x05,0x05,0xfd,0x8a,0x4a,0x22,0x00,0x05,0x05,0xfd,0x8a,0x24,0x00,
   0x4a,0x35,0x7e,0x00,0x84,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1c,0x00,0x22,0x00,
   0x06,0x05,0xfd,0x8a,0x4a,0x22,0x00,0x06,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x24,
   0x08,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x24,0x1c,0x00,0x22,0x00,0x07,0x05,0xfd,
   0x8a,0x22,0x00,0x10,0xc0,0x4a,0x22,0x00,0x07,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,
   0x34,0x7e,0x00,0x45,0x0d,0xfe,0x3c,0x00,0xfe,0x3c,0x24,0x03,0x4e,0x4f,0x25,0x1a,
   0x00,0x2d,0x7f,0x0e,0xfe,0x34,0x01,0xfe,0x34,0x24,0x02,0x57,0x54,0x1b,0x00,0x3c,
   0x80,0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,0x42,0x49,0x47,0x84,0x22,0x00,0x01,
   0x22,0x00,0x02,0x4c,0x00,0xfe,0x3c,0x6f,0x24,0x0b,0x20,0x46,0x69,0x73,0x68,0x20,
   0x66,0x6f,0x75,0x6e,0x64,0x71,0x73,0x63,0x51,0xfe,0xbf,0x0d,0xfe,0x6a,0x22,0x00,
   0x01,0x7f,0x22,0x00,0x01,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x15,0x22,0x00,
   0x01,0x12,0xfd,0x8a,0x24,0x0a,0x41,0x4c,0x4c,0x20,0x57,0x41,0x54,0x45,0x52,0x53,
   0x81,0x22,0x00,0x02,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x13,0x22,0x00,0x02,
   0x12,0xfd,0x8a,0x24,0x08,0x41,0x4c,0x4c,0x20,0x46,0x49,0x53,0x48,0x81,0x22,0x00,
   0x03,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x19,0x22,0x00,0x03,0x12,0xfd,0x8a,
   0x24,0x0e,0x41,0x4c,0x4c,0x20,0x46,0x4c,0x59,0x53,0x2f,0x42,0x41,0x49,0x54,0x53,
   0x81,0x22,0x00,0x04,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x1b,0x22,0x00,0x04,
   0x12,0xfd,0x8a,0x24,0x10,0x41,0x4c,0x4c,0x20,0x54,0x49,0x4d,0x45,0x53,0x20,0x4f,
   0x46,0x20,0x44,0x41,0x59,0x81,0x22,0x00,0x05,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,
   0x00,0x13,0x22,0x00,0x05,0x12,0xfd,0x8a,0x24,0x08,0x4e,0x4f,0x20,0x54,0x49,0x44,
   0x45,0x53,0x81,0x22,0x00,0x06,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x17,0x22,
   0x00,0x06,0x12,0xfd,0x8a,0x24,0x0c,0x41,0x4c,0x4c,0x20,0x57,0x45,0x41,0x54,0x48,
   0x45,0x52,0x53,0x81,0x22,0x00,0x07,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x15,
   0x22,0x00,0x07,0x12,0xfd,0x8a,0x24,0x0a,0x4e,0x4f,0x20,0x43,0x4f,0x4d,0x4d,0x45,
   0x4e,0x54,0x81,0x0d,0xfd,0x87,0x22,0x00,0x01,0x7f,0x00,0xfd,0x87,0x12,0xfd,0x8a,
   0x00,0xfd,0x87,0x05,0xfd,0x8a,0x20,0x02,0x20,0x01,0x7d,0x07,0x43,0x45,0x4e,0x54,
   0x52,0x45,0x24,0x81,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x00,
   0xfd,0x87,0x22,0x00,0x08,0x2c,0x7e,0xff,0xd3,0x0d,0xfe,0x6a,0x22,0x00,0x01,0x7f,
   0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x1f,0x46,0x49,0x53,0x48,0x49,0x4e,0x47,0x20,
   0x52,0x45,0x53,0x55,0x4c,0x54,0x53,0x20,0x20,0x46,0x4f,0x52,0x20,0x46,0x4f,0x4c,
   0x4c,0x4f,0x57,0x49,0x4e,0x47,0x3a,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,
   0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x02,0xfd,0x66,0x81,0x0d,0xfe,0x6a,
   0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x22,0x00,
   0x01,0x05,0xfd,0x8a,0x22,0x00,0x0f,0xb8,0x4b,0x22,0x00,0x02,0x05,0xfd,0x8a,0x4b,
   0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,
   0xfe,0x6d,0x22,0x00,0x03,0x05,0xfd,0x8a,0x22,0x00,0x0f,0xb8,0x4b,0x22,0x00,0x04,
   0x05,0xfd,0x8a,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,
   0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x22,0x00,0x05,0x05,0xfd,0x8a,0x22,0x00,0x0f,0xb8,
   0x4b,0x22,0x00,0x06,0x05,0xfd,0x8a,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,
   0x00,0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0b,0x20,0x20,0x20,0x20,
   0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x22,0x00,0x0f,0xb8,0x4b,0x22,0x00,0x07,0x05,
   0xfd,0x8a,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,
   0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0d,0x4e,0x4f,0x2e,0x4f,0x46,0x20,0x46,0x49,0x53,
   0x48,0x20,0x3d,0x20,0x22,0x00,0x0f,0xb8,0x4b,0x00,0xfe,0x3c,0x86,0x22,0x00,0x00,
   0x22,0x00,0x06,0xbb,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,
   0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0b,0x54,0x4f,0x54,0x41,0x4c,0x20,0x57,
   0x54,0x20,0x3d,0x20,0x22,0x00,0x0f,0xb8,0x4b,0x01,0xfe,0x34,0x22,0x00,0x02,0x22,
   0x00,0x08,0xbb,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,
   0x00,0xfe,0x3c,0x22,0x00,0x00,0x29,0x7e,0x00,0x2e,0x00,0xfe,0x6a,0x12,0xfe,0x6d,
   0x24,0x0b,0x41,0x56,0x45,0x52,0x41,0x47,0x45,0x20,0x57,0x54,0x3d,0x22,0x00,0x0f,
   0xb8,0x4b,0x01,0xfe,0x34,0x00,0xfe,0x3c,0x86,0x3f,0x22,0x00,0x02,0x22,0x00,0x08,
   0xbb,0x4b,0x81,0x51,0x00,0x1f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0b,0x41,0x56,
   0x45,0x52,0x41,0x47,0x45,0x20,0x57,0x54,0x3d,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x01,
   0x30,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,0xfe,
   0x6a,0x12,0xfe,0x6d,0x24,0x0a,0x42,0x45,0x53,0x54,0x20,0x46,0x49,0x53,0x48,0x3d,
   0x01,0xfe,0x62,0x22,0x00,0x01,0x22,0x00,0x05,0xbb,0x4b,0x22,0x00,0x0f,0xb8,0x4b,
   0x02,0xfe,0x51,0x4b,0x81,0x00,0xfe,0x3c,0x22,0x00,0x00,0x2c,0x7e,0x00,0x17,0x22,
   0x00,0x05,0x20,0x00,0x20,0x01,0x7d,0x08,0x46,0x49,0x53,0x48,0x4d,0x45,0x53,0x53,
   0x84,0x51,0x00,0x14,0x22,0x00,0x0c,0x20,0x00,0x20,0x01,0x7d,0x08,0x46,0x49,0x53,
   0x48,0x4d,0x45,0x53,0x53,0x84,0x4e,0x20,0x00,0x7d,0x06,0x52,0x45,0x53,0x55,0x4c,
   0x54,0x84,0x7b,0x00,0x00,0x09,0x83,0x50,0x41,0x43,0x4b,0x49,0x4e,0x20,0x20,0x00,
   0x02,0x80,0x00,0x59,0x00,0x55,0x00,0x06,0x00,0x43,0x00,0x00,0x00,0x00,0x05,0x03,
   0x44,0x52,0x24,0x02,0x00,0x00,0x00,0x00,0x0d,0xff,0xfa,0x24,0x18,0x41,0x2d,0x52,
   0x41,0x4d,0x2c,0x42,0x2d,0x50,0x41,0x43,0x4b,0x2c,0x43,0x2d,0x50,0x41,0x43,0x4b,
   0x2c,0x51,0x55,0x49,0x54,0x98,0x7f,0x00,0xff,0xfa,0x22,0x00,0x00,0x2c,0x7e,0x00,
   0x03,0x7b,0x16,0xff,0xfc,0x22,0x00,0x41,0x00,0xff,0xfa,0x2d,0x22,0x00,0x01,0x2e,
   0xb8,0x24,0x01,0x3a,0x4b,0x81,0x00,0xff,0xfa,0x86,0x79,0x00,0x00,0x09,0x83,0x45,
   0x58,0x49,0x53,0x54,0x24,0x20,0x20,0x00,0x02,0x80,0x00,0x57,0x00,0x53,0x00,0x16,
   0x00,0x3f,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xf8,0x02,0xff,0xec,0x0a,
   0x00,0x00,0x0f,0xff,0xf9,0x00,0xff,0xea,0x22,0x00,0x41,0x2d,0xb8,0x24,0x01,0x3a,
   0x4b,0x81,0x02,0xff,0xf9,0x09,0xff,0xfc,0x4b,0xa4,0x7e,0x00,0x0d,0x0f,0xff,0xed,
   0x02,0xff,0xf9,0x09,0xff,0xfc,0x4b,0x81,0x0d,0xff,0xea,0x00,0xff,0xea,0x22,0x00,
   0x01,0x2d,0x7f,0x00,0xff,0xea,0x22,0x00,0x03,0x2c,0x7e,0xff,0xc7,0x02,0xff,0xed,
   0x79,0x00,0x00,0x09,0x83,0x52,0x45,0x53,0x55,0x4c,0x54,0x20,0x20,0x00,0x02,0x80,
   0x00,0xc4,0x00,0xc0,0x00,0x0a,0x00,0xab,0x00,0x00,0x00,0x00,0x08,0x02,0x52,0x24,
   0x05,0x02,0x43,0x25,0x00,0x00,0x00,0x00,0x00,0x0d,0xff,0xf8,0x22,0x00,0x01,0x7f,
   0x4e,0x24,0x04,0x55,0x53,0x45,0x20,0x71,0x22,0x00,0x06,0xb8,0x71,0x24,0x05,0x20,
   0x41,0x4e,0x44,0x20,0x71,0x22,0x00,0x07,0xb8,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,
   0x0b,0x63,0x6c,0x65,0x61,0x72,0x20,0x3d,0x20,0x65,0x6e,0x64,0x71,0x73,0x22,0x00,
   0x1e,0x54,0x4e,0x00,0xff,0xf8,0x0c,0xff,0xfc,0x71,0x73,0x0d,0xff,0xf6,0x91,0x7f,
   0x00,0xff,0xf6,0x22,0x00,0x01,0x2c,0x7e,0x00,0x06,0x7b,0x51,0x00,0x2f,0x00,0xff,
   0xf6,0x22,0x00,0x03,0x2c,0x7e,0x00,0x10,0x0d,0xff,0xf8,0x00,0xff,0xf8,0x22,0x00,
   0x01,0x2e,0x7f,0x51,0x00,0x17,0x00,0xff,0xf6,0x22,0x00,0x04,0x2c,0x7e,0x00,0x0d,
   0x0d,0xff,0xf8,0x00,0xff,0xf8,0x22,0x00,0x01,0x2d,0x7f,0x00,0xff,0xf8,0x22,0x00,
   0x01,0x27,0x7e,0x00,0x0c,0x0d,0xff,0xf8,0x22,0x00,0x01,0x7f,0x51,0x00,0x13,0x00,
   0xff,0xf8,0x07,0xff,0xfa,0x29,0x7e,0x00,0x09,0x0d,0xff,0xf8,0x07,0xff,0xfa,0x7f,
   0x51,0xff,0x91,0x7b,0x00,0x00,0x09,0x83,0x46,0x49,0x53,0x48,0x42,0x49,0x47,0x20,
   0x00,0x02,0x80,0x00,0x41,0x00,0x3d,0x00,0x06,0x00,0x24,0x00,0x00,0x00,0x00,0x0c,
   0x03,0x42,0x49,0x47,0x01,0x05,0x42,0x44,0x41,0x59,0x24,0x02,0x00,0x00,0x00,0x00,
   0x24,0x02,0x57,0x54,0x1b,0x00,0x08,0xff,0xfc,0x38,0x7e,0x00,0x18,0x15,0xff,0xfc,
   0x24,0x02,0x57,0x54,0x1b,0x00,0x80,0x16,0xff,0xfa,0x24,0x04,0x44,0x41,0x59,0x24,
   0x1c,0x00,0x81,0x7b,0x00,0x00,0x09,0x83,0x46,0x49,0x53,0x48,0x4d,0x45,0x53,0x53,
   0x00,0x02,0x80,0x02,0xa6,0x02,0xa2,0x01,0x99,0x02,0x85,0x01,0x00,0x00,0x00,0x00,
   0x08,0x02,0x43,0x25,0x00,0x02,0x52,0x24,0x05,0x00,0x03,0xfe,0x69,0x20,0x00,0x04,
   0xfe,0x6a,0x00,0x0c,0x22,0x00,0x01,0x12,0xfe,0x6a,0x24,0x0e,0x20,0x57,0x68,0x61,
   0x74,0x21,0x20,0x4e,0x6f,0x20,0x66,0x69,0x73,0x68,0x22,0x00,0x0f,0xb8,0x4b,0x24,
   0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xb5,0xb8,0x22,0x00,0x05,0xc5,0x4b,
   0x81,0x22,0x00,0x02,0x12,0xfe,0x6a,0x24,0x0e,0x4e,0x6f,0x74,0x20,0x6d,0x75,0x63,
   0x68,0x20,0x6c,0x75,0x63,0x6b,0x21,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,
   0x20,0x20,0x20,0x4b,0x22,0x00,0xb3,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,
   0x03,0x12,0xfe,0x6a,0x24,0x0c,0x20,0x20,0x54,0x72,0x79,0x20,0x61,0x67,0x61,0x69,
   0x6e,0x21,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x24,
   0x01,0x3a,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x04,0x12,0xfe,0x6a,0x24,0x0f,
   0x43,0x68,0x61,0x6e,0x67,0x65,0x20,0x79,0x6f,0x75,0x72,0x20,0x72,0x6f,0x64,0x22,
   0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xb2,0xb8,
   0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x05,0x12,0xfe,0x6a,0x24,0x0d,0x20,0x20,
   0x47,0x6f,0x6f,0x64,0x20,0x43,0x61,0x74,0x63,0x68,0x20,0x22,0x00,0x0f,0xb8,0x4b,
   0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xfb,0xb8,0x22,0x00,0x05,0xc5,
   0x4b,0x81,0x22,0x00,0x06,0x12,0xfe,0x6a,0x24,0x0d,0x20,0x20,0x51,0x75,0x69,0x74,
   0x65,0x20,0x61,0x20,0x62,0x61,0x67,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,
   0x20,0x20,0x20,0x4b,0x22,0x00,0xfc,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,
   0x07,0x12,0xfe,0x6a,0x24,0x0d,0x20,0x20,0x54,0x69,0x67,0x68,0x74,0x20,0x6c,0x69,
   0x6e,0x65,0x73,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,
   0x22,0x00,0xb2,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x08,0x12,0xfe,0x6a,
   0x24,0x0f,0x4b,0x65,0x65,0x70,0x20,0x74,0x68,0x65,0x20,0x72,0x6f,0x64,0x20,0x75,
   0x70,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x24,0x01,
   0x2f,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x09,0x12,0xfe,0x6a,0x24,0x0f,0x20,
   0x20,0x2a,0x2a,0x20,0x57,0x4f,0x57,0x21,0x20,0x2a,0x2a,0x20,0x20,0x20,0x22,0x00,
   0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x24,0x01,0x2a,0x22,0x00,
   0x05,0xc5,0x4b,0x81,0x22,0x00,0x0a,0x12,0xfe,0x6a,0x24,0x0e,0x20,0x4f,0x69,0x6c,
   0x20,0x79,0x6f,0x75,0x72,0x20,0x72,0x65,0x65,0x6c,0x22,0x00,0x0f,0xb8,0x4b,0x24,
   0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xef,0xb8,0x22,0x00,0x05,0xc5,0x4b,
   0x81,0x22,0x00,0x0b,0x12,0xfe,0x6a,0x24,0x10,0x53,0x68,0x61,0x72,0x70,0x65,0x6e,
   0x20,0x79,0x6f,0x75,0x20,0x68,0x6f,0x6f,0x6b,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,
   0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xd2,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,
   0x22,0x00,0x0c,0x12,0xfe,0x6a,0x24,0x0e,0x20,0x20,0x48,0x65,0x61,0x74,0x20,0x74,
   0x68,0x65,0x20,0x70,0x61,0x6e,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,
   0x20,0x20,0x4b,0x22,0x00,0xdb,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x0d,0xfe,0x67,
   0x22,0x00,0x63,0x7f,0x00,0xfe,0x67,0x22,0x00,0x0c,0x29,0x00,0xfe,0x67,0x22,0x00,
   0x01,0x27,0x35,0x7e,0x00,0x37,0x07,0xff,0xfc,0x22,0x00,0x05,0x2c,0x7e,0x00,0x1a,
   0x0d,0xfe,0x67,0x22,0x00,0x01,0x86,0xb1,0x07,0xff,0xfc,0x86,0x3e,0x3c,0x22,0x00,
   0x01,0x86,0x3d,0x87,0x7f,0x51,0x00,0x12,0x0d,0xfe,0x67,0x22,0x00,0x05,0x86,0xb1,
   0x07,0xff,0xfc,0x86,0x3e,0x3c,0x87,0x7f,0x51,0xff,0xbb,0x14,0xff,0xfa,0x07,0xff,
   0xfa,0x22,0x00,0x01,0x2d,0x7f,0x07,0xff,0xfa,0x19,0xff,0xf8,0x00,0xfe,0x67,0x05,
   0xfe,0x6a,0x22,0x00,0x10,0xb8,0x4b,0x81,0x7b,0x00,0x00,0x09,0x83,0x43,0x45,0x4e,
   0x54,0x52,0x45,0x24,0x20,0x00,0x02,0x80,0x00,0x33,0x00,0x2f,0x00,0x16,0x00,0x1e,
   0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0xea,0x10,0x00,0x00,0x0f,0xff,0xeb,
   0x24,0x01,0x20,0x22,0x00,0x10,0x09,0xff,0xfc,0x96,0x2e,0x86,0x94,0x22,0x00,0x02,
   0x30,0xc5,0x09,0xff,0xfc,0x4b,0x81,0x02,0xff,0xeb,0x79,0x00,0x00,0x09,0x83,0x4d,
   0x41,0x44,0x55,0x44,0x47,0x20,0x20,0x00,0x02,0x80,0x00,0xce,0x00,0xca,0x00,0x16,
   0x00,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xff,0xec,0x00,0x08,0x22,
   0x00,0x01,0x10,0xff,0xec,0x22,0x00,0x04,0x7f,0x22,0x00,0x02,0x10,0xff,0xec,0x22,
   0x00,0x0e,0x7f,0x22,0x00,0x03,0x10,0xff,0xec,0x22,0x00,0x15,0x7f,0x22,0x00,0x04,
   0x10,0xff,0xec,0x22,0x00,0x04,0x7f,0x22,0x00,0x05,0x10,0xff,0xec,0x22,0x00,0x04,
   0x7f,0x22,0x00,0x06,0x10,0xff,0xec,0x22,0x00,0x04,0x7f,0x22,0x00,0x07,0x10,0xff,
   0xec,0x22,0x00,0x04,0x7f,0x22,0x01,0x80,0x22,0x00,0x40,0x22,0x00,0x06,0x22,0x00,
   0x07,0x34,0x22,0x00,0x08,0x2f,0x2d,0x55,0x0d,0xff,0xea,0x22,0x00,0x01,0x7f,0x22,
   0x01,0x81,0x00,0xff,0xea,0x03,0xff,0xec,0x55,0x0d,0xff,0xea,0x00,0xff,0xea,0x22,
   0x00,0x01,0x2d,0x7f,0x00,0xff,0xea,0x22,0x00,0x08,0x2c,0x7e,0xff,0xe3,0x22,0x01,
   0x80,0x22,0x00,0x40,0x22,0x00,0x07,0x22,0x00,0x07,0x34,0x22,0x00,0x08,0x2f,0x2d,
   0x55,0x0d,0xff,0xea,0x22,0x00,0x07,0x7f,0x22,0x01,0x81,0x00,0xff,0xea,0x03,0xff,
   0xec,0x55,0x0d,0xff,0xea,0x00,0xff,0xea,0x22,0x00,0x01,0x2e,0x7f,0x00,0xff,0xea,
   0x22,0x00,0x00,0x2c,0x7e,0xff,0xe3,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x44,0x49,
   0x52,0x20,0x20,0x20,0x00,0x02,0x80,0x00,0xfc,0x00,0xf8,0x00,0x16,0x00,0xe5,0x00,
   0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xf6,0x02,0xff,0xea,0x0a,0x00,0x00,0x53,0x00,
   0x25,0x0d,0xff,0xfa,0x22,0x00,0x00,0x7f,0x0d,0xff,0xfa,0x00,0xff,0xfa,0x22,0x00,
   0x01,0x2d,0x7f,0x00,0xff,0xfa,0x22,0x00,0x03,0x29,0x7e,0x00,0x09,0x0d,0xff,0xfa,
   0x22,0x00,0x01,0x7f,0x0f,0xff,0xf7,0x22,0x00,0x40,0x00,0xff,0xfa,0x2d,0xb8,0x24,
   0x01,0x3a,0x4b,0x81,0x4e,0x4f,0x01,0x24,0x0e,0x20,0x53,0x45,0x45,0x20,0x46,0x49,
   0x4c,0x45,0x53,0x20,0x4f,0x4e,0x20,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x09,0x20,
   0x20,0x20,0x44,0x52,0x49,0x56,0x45,0x20,0x71,0x02,0xff,0xf7,0x71,0x0d,0xff,0xfc,
   0x91,0x7f,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x08,0x51,0xff,0x9b,0x51,
   0x00,0x6d,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x08,0x51,0x00,0x60,0x51,
   0x00,0x5d,0x00,0xff,0xfc,0x22,0x00,0x0d,0x2c,0x7e,0x00,0x50,0x4e,0x0f,0xff,0xeb,
   0x02,0xff,0xf7,0xb7,0x81,0x02,0xff,0xeb,0x71,0x73,0x02,0xff,0xeb,0x24,0x00,0x4a,
   0x7e,0x00,0x1a,0x24,0x0f,0x2a,0x2a,0x45,0x4e,0x44,0x20,0x4f,0x46,0x20,0x50,0x41,
   0x43,0x4b,0x2a,0x2a,0x71,0x73,0x91,0x83,0x51,0x00,0x24,0x0f,0xff,0xf7,0x24,0x00,
   0x81,0x0d,0xff,0xfc,0x91,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x02,0xff,0xeb,
   0x24,0x00,0x4a,0x35,0x7e,0xff,0xb8,0x51,0x00,0x05,0x51,0xff,0x49,0x4f,0x00,0x53,
   0x00,0x00,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x42,0x59,0x54,0x45,0x20,0x20,0x00,
   0x02,0x80,0x00,0xd0,0x00,0xcc,0x00,0x0a,0x00,0xbc,0x00,0x00,0x00,0x00,0x00,0x00,
   0x03,0xff,0xf6,0x02,0x00,0x00,0x53,0x00,0x25,0x0d,0xff,0xfc,0x22,0x00,0x00,0x7f,
   0x0d,0xff,0xfc,0x00,0xff,0xfc,0x22,0x00,0x01,0x2d,0x7f,0x00,0xff,0xfc,0x22,0x00,
   0x03,0x29,0x7e,0x00,0x09,0x0d,0xff,0xfc,0x22,0x00,0x01,0x7f,0x0f,0xff,0xf7,0x22,
   0x00,0x40,0x00,0xff,0xfc,0x2d,0xb8,0x81,0x4e,0x4f,0x01,0x4e,0x24,0x0e,0x53,0x50,
   0x41,0x43,0x45,0x20,0x4f,0x4e,0x20,0x44,0x52,0x49,0x56,0x45,0x71,0x73,0x02,0xff,
   0xf7,0x71,0x24,0x01,0x3a,0x71,0x0d,0xff,0xfa,0x91,0x7f,0x00,0xff,0xfa,0x22,0x00,
   0x02,0x2c,0x7e,0x00,0x08,0x51,0xff,0xaa,0x51,0x00,0x47,0x00,0xff,0xfa,0x22,0x00,
   0x01,0x2c,0x7e,0x00,0x0b,0x53,0x00,0x00,0x4f,0x00,0x7b,0x51,0x00,0x34,0x00,0xff,
   0xfa,0x22,0x00,0x0d,0x2c,0x7e,0x00,0x2a,0x02,0xff,0xf7,0x24,0x05,0x3a,0x4d,0x41,
   0x49,0x4e,0x4b,0x65,0x01,0x02,0x02,0x54,0x24,0x88,0x22,0x00,0x04,0x22,0x00,0x02,
   0x4c,0x24,0x03,0x20,0x3d,0x20,0x71,0xb6,0x70,0x73,0x0d,0xff,0xfa,0x91,0x7f,0x5c,
   0x00,0xff,0xfa,0x22,0x00,0x01,0x2c,0x7e,0x00,0x06,0x7b,0x51,0x00,0x05,0x51,0xff,
   0x6d,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x44,0x45,0x4c,0x20,0x20,0x20,0x00,0x02,
   0x80,0x01,0x3a,0x01,0x36,0x00,0x16,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x09,
   0xff,0xf0,0x0a,0xff,0xed,0x01,0xff,0xea,0x01,0x00,0x00,0x53,0x01,0x1b,0x4e,0x24,
   0x0f,0x44,0x45,0x4c,0x45,0x54,0x45,0x20,0x41,0x20,0x46,0x49,0x4c,0x45,0x3f,0x3f,
   0x71,0x73,0x24,0x0e,0x43,0x4f,0x4e,0x54,0x49,0x4e,0x55,0x45,0x20,0x28,0x59,0x2f,
   0x4e,0x29,0x71,0x73,0x0f,0xff,0xee,0xbd,0xc7,0x81,0x02,0xff,0xee,0x24,0x01,0x59,
   0x49,0x7e,0x00,0x05,0x51,0x00,0xe2,0x4e,0x24,0x0f,0x45,0x4e,0x54,0x45,0x52,0x20,
   0x46,0x49,0x4c,0x45,0x20,0x4e,0x41,0x4d,0x45,0x71,0x73,0x0f,0xff,0xf1,0x6e,0x4e,
   0x0f,0xff,0xeb,0x02,0xff,0xf1,0x22,0x00,0x01,0xc0,0xc7,0x81,0x02,0xff,0xf1,0x24,
   0x00,0x4a,0x7e,0x00,0x08,0x51,0x00,0xb1,0x51,0x00,0xab,0x02,0xff,0xeb,0x24,0x01,
   0x41,0x45,0x02,0xff,0xeb,0x24,0x01,0x43,0x47,0x35,0x02,0xff,0xf1,0x22,0x00,0x02,
   0x22,0x00,0x01,0xc2,0x24,0x01,0x3a,0x49,0x35,0x7e,0x00,0x1d,0x24,0x0f,0x49,0x4e,
   0x43,0x4f,0x52,0x52,0x45,0x43,0x54,0x20,0x45,0x4e,0x54,0x52,0x59,0x71,0x73,0x91,
   0x83,0x51,0x00,0x75,0x51,0x00,0x6f,0x02,0xff,0xf1,0xa4,0x7e,0x00,0x54,0x4e,0x02,
   0xff,0xf1,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x0e,0x54,0x4f,0x20,0x42,0x45,0x20,
   0x44,0x45,0x4c,0x45,0x54,0x45,0x44,0x3f,0x71,0x73,0x0d,0xff,0xfc,0x91,0x7f,0x00,
   0xff,0xfc,0x22,0x00,0x0d,0x2b,0x7e,0x00,0x05,0x51,0x00,0x3d,0x02,0xff,0xf1,0x5f,
   0x4e,0x02,0xff,0xf1,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x0d,0x20,0x20,0x4e,0x4f,
   0x57,0x20,0x44,0x45,0x4c,0x45,0x54,0x45,0x44,0x71,0x73,0x91,0x83,0x51,0x00,0x16,
   0x24,0x0e,0x46,0x49,0x4c,0x45,0x20,0x4e,0x4f,0x54,0x20,0x46,0x4f,0x55,0x4e,0x44,
   0x71,0x73,0x91,0x83,0x51,0x00,0x02,0x53,0x00,0x00,0x7b,0x00,0x00,0x09,0x83,0x55,
   0x54,0x49,0x4c,0x53,0x20,0x20,0x20,0x00,0x02,0x80,0x00,0xdd,0x00,0xd9,0x00,0x04,
   0x00,0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0xff,0xfc,0x24,0x20,
   0x43,0x4f,0x4e,0x56,0x45,0x52,0x54,0x2c,0x53,0x50,0x41,0x43,0x45,0x2c,0x46,0x49,
   0x4c,0x45,0x53,0x2c,0x53,0x4f,0x55,0x4e,0x44,0x2c,0x44,0x45,0x4c,0x45,0x54,0x45,
   0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x0f,0x20,0x00,0x7d,0x05,
   0x55,0x43,0x4f,0x4e,0x56,0x84,0x51,0x00,0x8c,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,
   0x7e,0x00,0x10,0x20,0x00,0x7d,0x06,0x55,0x54,0x42,0x59,0x54,0x45,0x84,0x51,0x00,
   0x74,0x00,0xff,0xfc,0x22,0x00,0x03,0x2c,0x7e,0x00,0x0f,0x20,0x00,0x7d,0x05,0x55,
   0x54,0x44,0x49,0x52,0x84,0x51,0x00,0x5d,0x00,0xff,0xfc,0x22,0x00,0x04,0x2c,0x7e,
   0x00,0x11,0x20,0x00,0x7d,0x07,0x55,0x54,0x4e,0x4f,0x49,0x53,0x45,0x84,0x51,0x00,
   0x44,0x00,0xff,0xfc,0x22,0x00,0x05,0x2c,0x7e,0x00,0x39,0x24,0x0e,0x57,0x41,0x52,
   0x4e,0x49,0x4e,0x47,0x20,0x2d,0x20,0x54,0x48,0x49,0x53,0x71,0x22,0x00,0x0f,0xb8,
   0x71,0x24,0x0c,0x45,0x52,0x41,0x53,0x45,0x53,0x20,0x46,0x49,0x4c,0x45,0x53,0x71,
   0x73,0x22,0x00,0x1e,0x54,0x20,0x00,0x7d,0x05,0x55,0x54,0x44,0x45,0x4c,0x84,0x51,
   0x00,0x03,0x7b,0x51,0xff,0x37,0x7b,0x00,0x00,0x09,0x83,0x55,0x43,0x4f,0x4e,0x56,
   0x20,0x20,0x20,0x00,0x02,0x80,0x01,0xbd,0x01,0xb9,0x00,0x2e,0x01,0xa3,0x00,0x00,
   0x00,0x00,0x00,0x00,0x09,0xff,0xf5,0x05,0xff,0xf1,0x02,0xff,0xda,0x05,0x00,0x00,
   0x53,0x00,0x00,0x0d,0xff,0xfc,0x24,0x13,0x4c,0x42,0x53,0x2d,0x4b,0x49,0x4c,0x4f,
   0x53,0x2c,0x4b,0x49,0x4c,0x4f,0x53,0x2d,0x4c,0x42,0x53,0x98,0x7f,0x22,0x00,0x03,
   0x6a,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x08,0x51,0x00,0x16,0x51,0x00,
   0x13,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x08,0x51,0x00,0xcf,0x51,0x00,
   0x03,0x7b,0x53,0x00,0x00,0x53,0xff,0xfc,0x4e,0x24,0x10,0x45,0x4e,0x54,0x45,0x52,
   0x20,0x4c,0x42,0x53,0x3a,0x20,0x20,0x4f,0x5a,0x53,0x3a,0x71,0x73,0x22,0x00,0x07,
   0x22,0x00,0x02,0x4c,0x0f,0xff,0xf6,0x6e,0x22,0x00,0x0d,0x22,0x00,0x02,0x4c,0x0f,
   0xff,0xf2,0x6e,0x02,0xff,0xf6,0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xf6,0x24,
   0x01,0x30,0x81,0x02,0xff,0xf2,0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xf2,0x24,
   0x01,0x30,0x81,0x0e,0xff,0xe9,0x02,0xff,0xf6,0xb5,0x80,0x0e,0xff,0xe1,0x02,0xff,
   0xf2,0xb5,0x80,0x0e,0xff,0xe9,0x01,0xff,0xe9,0x01,0xff,0xe1,0x22,0x00,0x10,0x86,
   0x3f,0x3c,0x80,0x0e,0xff,0xd2,0x01,0xff,0xe9,0x23,0x04,0x92,0x35,0x45,0xff,0x3e,
   0x80,0x4e,0x22,0x00,0x01,0x22,0x00,0x01,0x4c,0x24,0x01,0x20,0x71,0x02,0xff,0xf6,
   0x71,0x24,0x06,0x20,0x4c,0x42,0x53,0x3a,0x20,0x71,0x02,0xff,0xf2,0x71,0x24,0x03,
   0x20,0x4f,0x5a,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x02,0x3d,0x20,
   0x71,0x01,0xff,0xd2,0x22,0x00,0x02,0x22,0x00,0x07,0xbb,0x71,0x24,0x06,0x20,0x4b,
   0x49,0x4c,0x4f,0x53,0x71,0x73,0x91,0x83,0x51,0xfe,0xf7,0x53,0x00,0x00,0x53,0xff,
   0xfc,0x4e,0x24,0x0c,0x45,0x4e,0x54,0x45,0x52,0x20,0x4b,0x49,0x4c,0x4f,0x53,0x3a,
   0x71,0x73,0x22,0x00,0x07,0x22,0x00,0x02,0x4c,0x0f,0xff,0xdb,0x6e,0x02,0xff,0xdb,
   0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xdb,0x24,0x01,0x30,0x81,0x0e,0xff,0xe9,
   0x02,0xff,0xdb,0xb5,0x23,0x05,0x30,0x62,0x04,0x22,0x00,0x3e,0x80,0x0e,0xff,0xe1,
   0x01,0xff,0xe9,0x01,0xff,0xe9,0x94,0x86,0x3d,0x80,0x0e,0xff,0xe1,0x01,0xff,0xe1,
   0x22,0x00,0x10,0x86,0x3e,0x80,0x4e,0x24,0x01,0x20,0x71,0x02,0xff,0xdb,0x71,0x24,
   0x06,0x20,0x4b,0x49,0x4c,0x4f,0x53,0x71,0x73,0x24,0x01,0x3d,0x71,0x01,0xff,0xe9,
   0x94,0x6f,0x24,0x06,0x20,0x4c,0x42,0x53,0x3a,0x20,0x71,0x01,0xff,0xe1,0x22,0x00,
   0x00,0x22,0x00,0x02,0xbb,0x71,0x24,0x03,0x20,0x4f,0x5a,0x71,0x73,0x91,0x83,0x51,
   0xfe,0x60,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x4e,0x4f,0x49,0x53,0x45,0x20,0x00,
   0x02,0x80,0x00,0x5f,0x00,0x5b,0x00,0x02,0x00,0x4e,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x4e,0x24,0x10,0x20,0x53,0x4f,0x55,0x4e,0x44,0x20,0x53,0x57,0x49,
   0x54,0x43,0x48,0x45,0x44,0x20,0x71,0x22,0x00,0xa4,0x9b,0x22,0x00,0x00,0x2c,0x7e,
   0x00,0x1a,0x22,0x00,0xa4,0x22,0x00,0x01,0x55,0x24,0x0a,0x20,0x20,0x20,0x20,0x20,
   0x20,0x20,0x4f,0x46,0x46,0x71,0x73,0x51,0x00,0x16,0x24,0x09,0x20,0x20,0x20,0x20,
   0x20,0x20,0x20,0x4f,0x4e,0x71,0x73,0x22,0x00,0xa4,0x22,0x00,0x00,0x55,0x91,0x83,
   0x7b,0x00,0x00,0xff,0xff,
  };
#endif

////////////////////////////////////////////////////////////////////////////////
//
typedef struct {
  FATFS fatfs;
  char const *const name;
} fatfs_dscr_t;

static fatfs_dscr_t fatfs_dscrs[2] = {{.name = "0:"}, {.name = "1:"}};
static FATFS *get_fs_by_name(const char *name) {
  for (size_t i = 0; i < count_of(fatfs_dscrs); ++i) {
    if (0 == strcmp(fatfs_dscrs[i].name, name)) {
      return &fatfs_dscrs[i].fatfs;
    }
  }
  return NULL;

}

static bool logger_enabled;
static const uint32_t period = 1000;
static absolute_time_t next_time;

void button_select_file(struct MENU_ELEMENT *e);

////////////////////////////////////////////////////////////////////////////////



// I2C functions
void i2c_release(I2C_PORT_DESC *port);
void i2c_delay(I2C_PORT_DESC *port);
void i2c_sda_low(I2C_PORT_DESC *port);
void i2c_sda_high(I2C_PORT_DESC *port);
void i2c_scl_low(I2C_PORT_DESC *port);
void i2c_scl_high(I2C_PORT_DESC *port);
void i2c_start(I2C_PORT_DESC *port);
void i2c_stop(I2C_PORT_DESC *port);
int i2c_send_byte(I2C_PORT_DESC *port, BYTE b);
int i2c_read_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
#


#endif /* I2C_FUNCTIONS_H_ */


/*
 * i2c_functions.c
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */
//#include "chip.h"
//#include "board.h"
//#include "i2c_functions.h"


// I2C functions

// Release the bus
void i2c_release(I2C_PORT_DESC *port) {
  // All inputs
  gpio_set_dir(SDA_PIN,GPIO_OUT);
  gpio_set_dir(SCL_PIN,GPIO_OUT);
  gpio_put(SDA_PIN, 0);
  gpio_put(SCL_PIN, 0);
  
  //  Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sdaport, port->sdabit);
  //Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sclport, port->sclbit);
}

// Delay to slow down to I2C bus rates
void i2c_delay(I2C_PORT_DESC *port) {
  sleep_us(1);
  return;
  volatile int i;
  for(i=0; i<1; i++)
    {
    }
  
}

void i2c_sda_low(I2C_PORT_DESC *port)
{
  // Take SCL low by driving a 0 on to the bus
  gpio_set_dir(SDA_PIN,GPIO_OUT);
  gpio_put(SDA_PIN, 0);
  //Chip_GPIO_SetPinState(LPC_GPIO, port->sdaport, port->sdabit, 0);
  
  // Make sure bit is an output
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, port->sdaport, port->sdabit);
}

void i2c_sda_high(I2C_PORT_DESC *port)
{
  // Make sure bit is an input
  gpio_set_dir(SDA_PIN,GPIO_IN);
  //  gpio_put(SDA_PIN, 1);
  //  Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sdaport, port->sdabit);
}

void i2c_scl_low(I2C_PORT_DESC *port) {

  gpio_set_dir(SCL_PIN,GPIO_OUT);
  gpio_put(SCL_PIN, 0);
  
  //  Chip_GPIO_SetPinState(LPC_GPIO, port->sclport, port->sclbit, 0);

  // Make sure bit is an output
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, port->sclport, port->sclbit);
}

void i2c_scl_high(I2C_PORT_DESC *port)
{
  // Make sure bit is an input
  gpio_set_dir(SCL_PIN, GPIO_IN);
  //gpio_put(SCL_PIN, 1);
  //Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sclport, port->sclbit);
}

// Read ACK bit

int i2c_read_sda(I2C_PORT_DESC *port)
{
  return(gpio_get(SDA_PIN));
  //  return(Chip_GPIO_GetPinState(LPC_GPIO, port->sdaport, port->sdabit));

  //  return( ((*(port->port)) & (port->sda_mask)) == port->sda_mask);
}

// I2C start condition

void i2c_start(I2C_PORT_DESC *port)
{
  //
  i2c_sda_low(port);

  i2c_delay(port);
  i2c_scl_low(port);
  i2c_delay(port);
}

void i2c_stop(I2C_PORT_DESC *port)
{
  i2c_scl_high(port);
  i2c_delay(port);
  i2c_sda_high(port);
  i2c_delay(port);

}

// Send 8 bits and read ACK
// Returns number of acks received

int i2c_send_byte(I2C_PORT_DESC *port, BYTE b)
{
  int i;
  int ack=0;
  int retries = 100;
  int rc =1;

  for (i = 0; i < 8; i++)
    {
      // Set up data
      if ((b & 0x80) == 0x80)
	{
	  i2c_sda_high(port);
	} else
	{
	  i2c_sda_low(port);
	}

      // Delay
      i2c_delay(port);

      // Take clock high and then low
      i2c_scl_high(port);

      // Delay
      i2c_delay(port);

      // clock low again
      i2c_scl_low(port);

      // Delay
      i2c_delay(port);

      // Shift next data bit in
      b <<= 1;
    }

  // release data line
  i2c_sda_high(port);

  // Now get ACK
  i2c_scl_high(port);

  i2c_delay(port);

  // read ACK

  while( ack = i2c_read_sda(port) ) // @suppress("Assignment in condition")
    {
      retries--;

      if ( retries == 0 )
	{
	  rc = 0;
	  break;
	}
    }

  i2c_scl_low(port);

  i2c_delay(port);
  return (rc);
}


// Receive 8 bits and set ACK
// Ack as specified
void i2c_recv_byte(I2C_PORT_DESC *port, BYTE *data, int ack)
{
  int i, b;

  b = 0;

  // Make data an input
  i2c_sda_high(port);

  for (i = 0; i < 8; i++)
    {
      // Delay
      i2c_delay(port);

      // Take clock high and then low
      i2c_scl_high(port);

      // Delay
      i2c_delay(port);

      // Shift next data bit in
      b <<= 1;
      b += (i2c_read_sda(port) & 0x1);

      // clock low again
      i2c_scl_low(port);

      // Delay
      i2c_delay(port);

    }

  // ACK is as we are told 
  if ( ack )
    {
      // Data low for ACK
      i2c_sda_low(port);
    }
  else
    {
      i2c_sda_high(port);
    }

  // Now send ACK
  i2c_scl_high(port);

  i2c_delay(port);

  i2c_scl_low(port);

  i2c_delay(port);

  *data = b;

}

// Reads a block of bytes from a slave

int i2c_read_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data)
{
  int i;
  BYTE byte;

  i2c_start(slave->port);

  // Send slave address with read bit
  if ( !i2c_send_byte(slave->port, ((slave->slave_7bit_addr) << 1) | 1) )
    {
      i2c_stop(slave->port);
      return(0);
    }


  //
  for (i = 0; i < n; i++)
    {
      i2c_recv_byte(slave->port, &byte, (i==(n-1))? 0 : 1);
      *(data++) = byte;
    }

  i2c_stop(slave->port);

  return(1);
}

// Sends a block of data to I2C slave
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data)
{
  int i;

  i2c_start(slave->port);

  // Send slave address with read bit
  i2c_send_byte(slave->port, ((slave->slave_7bit_addr) << 1) | 0);

  //
  for (i = 0; i < n; i++)
    {
      i2c_send_byte(slave->port, *(data++));
    }

  i2c_stop(slave->port);
}

void i2c_init(I2C_PORT_DESC *port)
{
  gpio_init(SDA_PIN);
  gpio_init(SCL_PIN);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 19);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 2);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 18);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 7);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 1, 19);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 1, 20);
}

/*
 * oled096.h
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */

#ifndef OLED096_H_
#define OLED096_H_

#define I2C_CMD       1
#define I2C_DATA      0
#define I2C_REPEAT    1
#define I2C_NO_REPEAT 0

void oled_send_cmd(I2C_SLAVE_DESC *slave, int n, unsigned char *data, int command, int repeat);
void oled_set_xy(I2C_SLAVE_DESC *slave, int x, int y);
void oled_set_pixel_xy(I2C_SLAVE_DESC *slave, int x, int y);
void oled_set_byte_xy(I2C_SLAVE_DESC *slave, int x, int y, int b);
void oled_gap(I2C_SLAVE_DESC *slave);
void oled_display_int(I2C_SLAVE_DESC *slave, long int n, int num_digits);
void oled_display_string(I2C_SLAVE_DESC *slave, char *string);
void oled_clear_display(I2C_SLAVE_DESC *slave);

void oled_setup(I2C_SLAVE_DESC *slave);
void oled_display_scaled_string_xy(I2C_SLAVE_DESC *slave, char *string, int x, int y, int scale);

extern const unsigned char font_5x7_letters[];

#endif /* OLED096_H_ */

/*
 * oled096.c
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */

//
// 0.96" OLED display functions
//


// Sends a block of commands to the SSD1306
// command causes 80 to be sent before each byte
// command = 0 causes 0x40 and just data bytes
// Repeat = 1, repeat data byte 0

//#include <string.h>
//#include "i2c_functions.h"
//#include "oled096.h"

void oled_send_cmd(I2C_SLAVE_DESC *slave, int n, unsigned char *data, int command, int repeat)
{
  int i;

  i2c_start(slave->port);

  // Send slave address
  i2c_send_byte(slave->port, (slave->slave_7bit_addr)<<1);

  if ( !command )
    {
      i2c_send_byte(slave->port, 0x40);
    }

  // Send the command bytes, each preceded bu 0x80 (continuation)
  for (i = 0; i < n; i++) {
    if ( command )
      {
        i2c_send_byte(slave->port, 0x80);
      }
    i2c_send_byte(slave->port, *data);

    if ( !repeat )
      {
	data++;
      }
  }

  i2c_stop(slave->port);
}

//--------------------------------------------------------------------------------
// OLED display functions
//

const unsigned char init_seq[] = {
				  0xae,                       // ???
				  0xd5, 0x80,

				  0xa8,0x3f,

				  0xd3,0x00,
				  0x8d,0x14,0x40,0xa6,0xa4,0xa1,0xc8,0xda,0x12,0x81,0x8f,
				  0xd9,         //??

				  0xf1,0xdb,0x40,0xaf,
};

// From data sheet
const unsigned char init_seq2[] = {
				   //  0xae,          // Display Off
#if PICOPAK
				   0xa8,0x1f,       // MUX ratio works for now
#else
				   0xa8,0x3f,       // MUX ratio works for now
#endif
				   0xd3,0x00,       // Set display offset 0
				   0x40,            // Set display start Line
				   0x8d,0x14,       // Charge pump ON, needed or blank display
				   0xa1,            // Seg remap 180 rotate
				   0xc8,            // Inverted COM scan
#if PICOPAK				   
				   0xda, 0x02,      // COM config: A5:Disable left/right remap, A4:Alternate COM pin config from 12
#else
				   0xda, 0x12,      // COM config: A5:Disable left/right remap, A4:Alternate COM pin config from 12
#endif
				   0x81,0x2f,      // Contrast value
				   0xd9, 0xf1,     // Precharge, quite important
				   0xdb, 0x40,     // Set Vcomh level, leave it out and inverted display.

				   0xa6,            // Normal display (not inverted)
				   0xd5,0x80,       // Set display oscillator

				   0x20, 0x02,        // Page addressing mode
				   0x21,0x00,0x7f,               // Set display RAM start and end address
				   // seems to have effect in page addressing mode.
				   0x22,0x00,0x07,               // Set display page address

				   0xa4,
				   0xaf,             // Display ON
};

const unsigned char display_setup_seq[] = {
					   0x21,0x00,0x7f,               // Set display RAM start and end address
					   0x22,0x00,0x3f,               // Set display page address
};


const unsigned char display_text_seq[] = {
					  0x7e,0x11,0x11,0x11,0x7e,0x00,0x7f,0x49,0x49,0x49,0x36,0x00,0x00,0x3e,0x41,0x41,0x41,0x22,0x00,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,0x7f,0x49,0x49,0x49,0x41,0x00,
};

// Set XY to given position
// We attempt to position to the byte that holds the pixel (x,y)
// Page addressing mode

void oled_set_xy(I2C_SLAVE_DESC *slave, int x, int y)
{
  unsigned char seq[3];

  x = x % 128;
  y = y % 64;
  seq[0] = 0xB0+y/8;      // Set page
  seq[1] = 0x00+x%16;     // Set low part of start address
  seq[2] = 0x10+x/16;     // Set high part

  oled_send_cmd(slave, sizeof(seq), &(seq[0]), I2C_CMD, I2C_NO_REPEAT);
}

unsigned char byteval[1];

// Writes bit pattern at x,y
void oled_set_pixel_xy(I2C_SLAVE_DESC *slave, int x, int y)

{
  byteval[0] = 1<< (y % 8);

  oled_set_xy(slave, x, y);
  oled_send_cmd(slave, 1, &(byteval[0]), I2C_DATA, I2C_NO_REPEAT);
}


////////////////////////////////////////////////////////////////////////////////
// Menu system
//


int but_pins[NUM_BUTTONS] = {SW0_PIN, SW1_PIN, SW2_PIN};


void but_ev_up();
void but_ev_down();
void but_ev_select();
void draw_menu(I2C_SLAVE_DESC *slave, struct MENU_ELEMENT *e, bool clear);


struct MENU_ELEMENT *current_menu;
int file_menu_size = 0;

struct MENU_ELEMENT *last_menu;
struct MENU_ELEMENT *the_home_menu;
int menu_selection = 0;
//unsigned int menu_size = 0;

#define MAX_LISTFILES 200
#define MAX_NAME 20

struct MENU_ELEMENT listfiles[MAX_LISTFILES+1];
int num_listfiles;
char names[MAX_LISTFILES][MAX_NAME];
char current_file[MAX_NAME+1];

// read the file with the given name into the buffer

void core_read(I2C_SLAVE_DESC *slave, char *arg);
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
#

I2C_PORT_DESC i2c_bus_0 =
  {
   0, 18,
   0, 7,
  };

// Dummy structure
I2C_SLAVE_DESC oled0 =
  {
   &i2c_bus_0,
   0x78 >>1,
  };


void oled_set_byte_xy(I2C_SLAVE_DESC *slave, int x, int y, int b)
{
  byteval[0] = b;

  oled_set_xy(slave, x, y);
  oled_send_cmd(slave, 1, &(byteval[0]), I2C_DATA, I2C_NO_REPEAT);
}


// Font

const unsigned char font_5x7_letters[] = {
					  0x00, 0x00, 0x00, 0x00, 0x00,// (space)
					  0x00, 0x00, 0x5F, 0x00, 0x00,// !
					  0x00, 0x07, 0x00, 0x07, 0x00,// "
					  0x14, 0x7F, 0x14, 0x7F, 0x14,// #
					  0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
					  0x23, 0x13, 0x08, 0x64, 0x62,// %
					  0x36, 0x49, 0x55, 0x22, 0x50,// &
					  0x00, 0x05, 0x03, 0x00, 0x00,// '
					  0x00, 0x1C, 0x22, 0x41, 0x00,// (
					  0x00, 0x41, 0x22, 0x1C, 0x00,// )
					  0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
					  0x08, 0x08, 0x3E, 0x08, 0x08,// +
					  0x00, 0x50, 0x30, 0x00, 0x00,// ,
					  0x08, 0x08, 0x08, 0x08, 0x08,// -
					  0x00, 0x60, 0x60, 0x00, 0x00,// .
					  0x20, 0x10, 0x08, 0x04, 0x02,// /
					  0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
					  0x00, 0x42, 0x7F, 0x40, 0x00,// 1
					  0x42, 0x61, 0x51, 0x49, 0x46,// 2
					  0x21, 0x41, 0x45, 0x4B, 0x31,// 3
					  0x18, 0x14, 0x12, 0x7F, 0x10,// 4
					  0x27, 0x45, 0x45, 0x45, 0x39,// 5
					  0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
					  0x01, 0x71, 0x09, 0x05, 0x03,// 7
					  0x36, 0x49, 0x49, 0x49, 0x36,// 8
					  0x06, 0x49, 0x49, 0x29, 0x1E,// 9
					  0x00, 0x36, 0x36, 0x00, 0x00,// :
					  0x00, 0x56, 0x36, 0x00, 0x00,// ;
					  0x00, 0x08, 0x14, 0x22, 0x41,// <
					  0x14, 0x14, 0x14, 0x14, 0x14,// =
					  0x41, 0x22, 0x14, 0x08, 0x00,// >
					  0x02, 0x01, 0x51, 0x09, 0x06,// ?
					  0x32, 0x49, 0x79, 0x41, 0x3E,// @
					  0x7E, 0x11, 0x11, 0x11, 0x7E,// A
					  0x7F, 0x49, 0x49, 0x49, 0x36,// B
					  0x3E, 0x41, 0x41, 0x41, 0x22,// C
					  0x7F, 0x41, 0x41, 0x22, 0x1C,// D
					  0x7F, 0x49, 0x49, 0x49, 0x41,// E
					  0x7F, 0x09, 0x09, 0x01, 0x01,// F
					  0x3E, 0x41, 0x41, 0x51, 0x32,// G
					  0x7F, 0x08, 0x08, 0x08, 0x7F,// H
					  0x00, 0x41, 0x7F, 0x41, 0x00,// I
					  0x20, 0x40, 0x41, 0x3F, 0x01,// J
					  0x7F, 0x08, 0x14, 0x22, 0x41,// K
					  0x7F, 0x40, 0x40, 0x40, 0x40,// L
					  0x7F, 0x02, 0x04, 0x02, 0x7F,// M
					  0x7F, 0x04, 0x08, 0x10, 0x7F,// N
					  0x3E, 0x41, 0x41, 0x41, 0x3E,// O
					  0x7F, 0x09, 0x09, 0x09, 0x06,// P
					  0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
					  0x7F, 0x09, 0x19, 0x29, 0x46,// R
					  0x46, 0x49, 0x49, 0x49, 0x31,// S
					  0x01, 0x01, 0x7F, 0x01, 0x01,// T
					  0x3F, 0x40, 0x40, 0x40, 0x3F,// U
					  0x1F, 0x20, 0x40, 0x20, 0x1F,// V
					  0x7F, 0x20, 0x18, 0x20, 0x7F,// W
					  0x63, 0x14, 0x08, 0x14, 0x63,// X
					  0x03, 0x04, 0x78, 0x04, 0x03,// Y
					  0x61, 0x51, 0x49, 0x45, 0x43,// Z
					  0x00, 0x00, 0x7F, 0x41, 0x41,// [
					  0x02, 0x04, 0x08, 0x10, 0x20,// "\"
					  0x41, 0x41, 0x7F, 0x00, 0x00,// ]
					  0x04, 0x02, 0x01, 0x02, 0x04,// ^
					  0x40, 0x40, 0x40, 0x40, 0x40,// _
					  0x00, 0x01, 0x02, 0x04, 0x00,// `
					  0x20, 0x54, 0x54, 0x54, 0x78,// a
					  0x7F, 0x48, 0x44, 0x44, 0x38,// b
					  0x38, 0x44, 0x44, 0x44, 0x20,// c
					  0x38, 0x44, 0x44, 0x48, 0x7F,// d
					  0x38, 0x54, 0x54, 0x54, 0x18,// e
					  0x08, 0x7E, 0x09, 0x01, 0x02,// f
					  0x08, 0x14, 0x54, 0x54, 0x3C,// g
					  0x7F, 0x08, 0x04, 0x04, 0x78,// h
					  0x00, 0x44, 0x7D, 0x40, 0x00,// i
					  0x20, 0x40, 0x44, 0x3D, 0x00,// j
					  0x00, 0x7F, 0x10, 0x28, 0x44,// k
					  0x00, 0x41, 0x7F, 0x40, 0x00,// l
					  0x7C, 0x04, 0x18, 0x04, 0x78,// m
					  0x7C, 0x08, 0x04, 0x04, 0x78,// n
					  0x38, 0x44, 0x44, 0x44, 0x38,// o
					  0x7C, 0x14, 0x14, 0x14, 0x08,// p
					  0x08, 0x14, 0x14, 0x18, 0x7C,// q
					  0x7C, 0x08, 0x04, 0x04, 0x08,// r
					  0x48, 0x54, 0x54, 0x54, 0x20,// s
					  0x04, 0x3F, 0x44, 0x40, 0x20,// t
					  0x3C, 0x40, 0x40, 0x20, 0x7C,// u
					  0x1C, 0x20, 0x40, 0x20, 0x1C,// v
					  0x3C, 0x40, 0x30, 0x40, 0x3C,// w
					  0x44, 0x28, 0x10, 0x28, 0x44,// x
					  0x0C, 0x50, 0x50, 0x50, 0x3C,// y
					  0x44, 0x64, 0x54, 0x4C, 0x44,// z
					  0x00, 0x08, 0x36, 0x41, 0x00,// {
					  0x00, 0x00, 0x7F, 0x00, 0x00,// |
					  0x00, 0x41, 0x36, 0x08, 0x00,// }
					  0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
					  0x08, 0x1C, 0x2A, 0x08, 0x08 // <-
};

// Turn display off
const unsigned char off_seq = {
			       0xae
};

// Turn display on
const unsigned char on_seq = {
			      0xaf
};


// Prints a character gap
void oled_gap(I2C_SLAVE_DESC *slave)
{
  unsigned char zero = 0;

  oled_send_cmd(slave, 1, &zero, I2C_DATA, I2C_NO_REPEAT);
}

// Displays an integer in decimal, number of digits displayed is specified, MS digits dropped

void oled_display_int(I2C_SLAVE_DESC *slave, long int n, int num_digits)
{
  int i;
  int dig;
  int mul = 10000;

  if( n < 0 )
    {
      oled_display_string(slave, "-");
      n = -n;
    }
  else
    {
      oled_display_string(slave, " ");
    }

  for(i=5; i>0; i--)
    {
      dig = n / mul;
      n = n % mul;
      mul /=10;

      // Display digit
      if ( i <= num_digits )
	{
	  oled_send_cmd(slave, 5, font_5x7_letters+('0'-' ')*5+dig*5, I2C_DATA, I2C_NO_REPEAT);
	  oled_gap(slave);
	}
    }
}

void oled_display_string(I2C_SLAVE_DESC *slave, char *string)
{
  int j;
  int len = strlen(string);

  for(j=0; j<len; j++)
    {
      oled_send_cmd(slave, 5, font_5x7_letters+((*string++) - ' ')*5, I2C_DATA, I2C_NO_REPEAT);
      oled_gap(slave);
    }
}

BYTE zero = 0;
void oled_clear_display(I2C_SLAVE_DESC *slave)
{
  int y;

  for(y=0; y<64; y+=8)
    {
      oled_set_xy(slave, 0, y);
      oled_send_cmd(slave, 128, &zero, I2C_DATA, I2C_REPEAT);
    }

}

//
// Displays a string with pixel scaling
//
unsigned char scaled_line[100];

void oled_display_scaled_string_xy(I2C_SLAVE_DESC *slave, char *string, int x, int y, int scale)
{
  unsigned char i;
  int  j, k, s;
  int scale_i;
  int len = strlen(string);
  int b;

  // We now display the string a character at a time, each character being scaled
  scale_i = 0;

  for(k=0; k<len; k++)
    {
      // Scale character
      // We start with 5 bytes, each of 8 bits, these are vertical slices of the bit pattern
      // We need to stretch the character vertically by scale

      for(i=0; i<5; i++)
	{
	  // For each byte we build a new bitmap that is scaled
	  for(j=0; j<8; j++)
	    {
	      // Get next bit
	      b  = (*(font_5x7_letters+((*string)-' ')*5+i));
	      b &= (1 << (7-j));
	      b >>= (7-j);

	      // Shift more bits in to scaled data
	      for(s=0; s<scale;s++)
		{
		  scaled_line[scale_i/8] <<= 1;
		  scaled_line[scale_i/8] |= b;
		  scale_i++;
		}
	    }
#if 0
	  // Move to next byte
	  while( (scale_i % 8) != 0 )
	    {
	      scale_i++;
	    }
#endif
	}

      // Put a gap between chars
      for(s=0; s<scale;s++)
	{
	  scaled_line[scale_i/8] = 0;
	  scale_i+=8;
	}

      string++;
    }

  // Send scaled data to display
  for(j=0; j < scale; j++)
    {
      oled_set_xy(slave, x, y+8*((scale-1)-j));
      for(i=0; i<5*len*scale; i+=scale)
	{
	  for(s=0; s<scale;s++)
	    {
	      oled_send_cmd(slave, 1, &(scaled_line[i+j]), I2C_DATA, I2C_NO_REPEAT);
	    }
	}
      oled_gap(slave);
    }

#if 0
  oled_set_xy(slave, 0,0);
  for(j=0;j<scale_i/8;j++)
    {
      oled_send_cmd(slave, 1, &(scaled_line[j]), I2C_DATA, I2C_NO_REPEAT);
    }


  oled_set_xy(slave, 30, 24);
  oled_display_int(slave, scale_i,5);
  oled_set_xy(slave, 30, 32);
  oled_display_int(slave, len,5);
#endif
}

void oled_error(char *str)
{
  oled_clear_display(&oled0);
  
  oled_set_xy(&oled0, 0,0);
  oled_display_string(&oled0, str);

  loop_delay(3000000);
}

void oled_setup(I2C_SLAVE_DESC *slave)
{
  int i;

  // Release bus
  i2c_release(slave->port);

  // Delay to allow things to start up.
  for(i=0; i<10000; i++)
    {
    }

  // Then clear any glitched I2C commands with a start and stop
  i2c_start(slave->port);
  i2c_stop(slave->port);

  // Initialise display
  oled_send_cmd(slave, sizeof(init_seq2), &(init_seq2[0]), 1, 0);

  // Clear display
  oled_clear_display(slave);


}

static void run_setrtc() {
  const char *dateStr = strtok(NULL, " ");
  if (!dateStr) {
    printf("Missing argument\n");
    return;
  }
  int date = atoi(dateStr);

  const char *monthStr = strtok(NULL, " ");
  if (!monthStr) {
    printf("Missing argument\n");
    return;
  }
  int month = atoi(monthStr);

  const char *yearStr = strtok(NULL, " ");
  if (!yearStr) {
    printf("Missing argument\n");
    return;
  }
  int year = atoi(yearStr) + 2000;

  const char *hourStr = strtok(NULL, " ");
  if (!hourStr) {
    printf("Missing argument\n");
    return;
  }
  int hour = atoi(hourStr);

  const char *minStr = strtok(NULL, " ");
  if (!minStr) {
    printf("Missing argument\n");
    return;
  };
  int min = atoi(minStr);

  const char *secStr = strtok(NULL, " ");
  if (!secStr) {
    printf("Missing argument\n");
    return;
  }
  int sec = atoi(secStr);

  datetime_t t = {.year = year,
		  .month = month,
		  .day = date,
		  .dotw = 0,  // 0 is Sunday, so 5 is Friday
		  .hour = hour,
		  .min = min,
		  .sec = sec};
  // bool r = rtc_set_datetime(&t);
  setrtc(&t);
}
static void run_lliot() {
  size_t pnum = 0;
  char *arg1 = strtok(NULL, " ");
  if (arg1) {
    pnum = strtoul(arg1, NULL, 0);
  }
  //lliot(pnum);
}
static void run_date() {
  char buf[128] = {0};
  time_t epoch_secs = time(NULL);
  struct tm *ptm = localtime(&epoch_secs);
  size_t n = strftime(buf, sizeof(buf), "%c", ptm);
  myASSERT(n);
  printf("%s\n", buf);
  strftime(buf, sizeof(buf), "%j",
	   ptm);  // The day of the year as a decimal number (range
  // 001 to 366).
  printf("Day of year: %s\n", buf);
}
static void run_format() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  FATFS *p_fs = get_fs_by_name(arg1);
  if (!p_fs) {
    printf("Unknown logical drive number: \"%s\"\n", arg1);
    return;
  }
  /* Format the drive with default parameters */
  FRESULT fr = f_mkfs(arg1, 0, 0, FF_MAX_SS * 2);
  if (FR_OK != fr) printf("f_mkfs error: %s (%d)\n", FRESULT_str(fr), fr);
}
static void run_mount() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "0:";
  FATFS *p_fs = get_fs_by_name(arg1);
  if (!p_fs) {
    printf("Unknown logical drive number: \"%s\"\n", arg1);
    return;
  }
  FRESULT fr = f_mount(p_fs, arg1, 1);
  if (FR_OK != fr) printf("f_mount error: %s (%d)\n", FRESULT_str(fr), fr);
}
static void run_unmount() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "";
  FRESULT fr = f_unmount(arg1);
  if (FR_OK != fr) printf("f_mount error: %s (%d)\n", FRESULT_str(fr), fr);
}
static void run_chdrive() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "0:";
  FRESULT fr = f_chdrive(arg1);
  if (FR_OK != fr) printf("f_mount error: %s (%d)\n", FRESULT_str(fr), fr);
}
static void run_getfree() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "0:";
  DWORD fre_clust, fre_sect, tot_sect;
  /* Get volume information and free clusters of drive */
  FATFS *p_fs = get_fs_by_name(arg1);
  if (!p_fs) {
    printf("Unknown logical drive number: \"%s\"\n", arg1);
    return;
  }
  FRESULT fr = f_getfree(arg1, &fre_clust, &p_fs);
  if (FR_OK != fr) {
    printf("f_getfree error: %s (%d)\n", FRESULT_str(fr), fr);
    return;
  }
  /* Get total sectors and free sectors */
  tot_sect = (p_fs->n_fatent - 2) * p_fs->csize;
  fre_sect = fre_clust * p_fs->csize;
  /* Print the free space (assuming 512 bytes/sector) */
  printf("%10lu KiB total drive space.\n%10lu KiB available.\n", tot_sect / 2,
	 fre_sect / 2);
}
static void run_cd() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  FRESULT fr = f_chdir(arg1);
  if (FR_OK != fr) printf("f_mkfs error: %s (%d)\n", FRESULT_str(fr), fr);
}
static void run_mkdir() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  FRESULT fr = f_mkdir(arg1);
  if (FR_OK != fr) printf("f_mkfs error: %s (%d)\n", FRESULT_str(fr), fr);
}

////////////////////////////////////////////////////////////////////////////////
//
// Scans the directory and works out the next file number to use
//
// Leaves max_filenum with that value
//
////////////////////////////////////////////////////////////////////////////////

void find_next_file_number(void)
{
  int file_n = 0;
  num_listfiles = 0;
  int i;
  
  char cwdbuf[FF_LFN_BUF] = {0};
  FRESULT fr;
  char const *p_dir;

  //DEBUG_STOP;

  if( cd_to_pak_dir(&oled0) )
    {
      return;
    }
  
  fr = f_getcwd(cwdbuf, sizeof cwdbuf);

  // printf will print to console
  if (FR_OK != fr)
    {
      printf("f_getcwd error: %s (%d)\n", FRESULT_str(fr), fr);
      return;
    }
  
  p_dir = cwdbuf;

  printf("File num search: %s\n", p_dir);
  
  DIR dj;      /* Directory object */
  FILINFO fno; /* File information */

  memset(&dj, 0, sizeof dj);
  memset(&fno, 0, sizeof fno);

  max_filenum = 0;
  
  fr = f_findfirst(&dj, &fno, p_dir, PAK_FILE_NAME_GLOB);

  if (FR_OK != fr)
    {
      printf("f_findfirst error: %s (%d)\n", FRESULT_str(fr), fr);
      return;
    }
  
  while( (fr == FR_OK) && fno.fname[0])
    { 
       if (fno.fattrib & AM_DIR)
	 {
	   // Directory, we ignore these
	 }
       else
	 {
	   int filenum;
	   sscanf(fno.fname, "pak%d.opk", &filenum);

	   if( filenum > max_filenum )
	     {
	       max_filenum = filenum;
	     }
	 }
       
      fr = f_findnext(&dj, &fno); /* Search for next item */
    }
  f_closedir(&dj);


}

// Mount the Sd card.
// These could be menu options for plug/unplug of cards
// Sets sd_ok flag for later use
FATFS p_fs;

void mount_sd(void)
{
  //  p_fs = get_fs_by_name("0:");

  sd_ok_flag = false;

#if 0
  if (!p_fs)
  {
      oled_error("Mount:Unknown drive:'0:'");
      return;
    }
#endif
  
  FRESULT fr = f_mount(&p_fs, "0:", 1);
  
  if (FR_OK != fr)
    {
      oled_error("Mount error");
      return;
    }

  sd_ok_flag = true;
}

void unmount_sd(void)
{
  f_unmount("0:");
}

////////////////////////////////////////////////////////////////////////////////
//
// Puts up a list of the files on the SD card PAK directory, so one can be
// chosen.
//
// Only displays .opk files as they are the only ones that can be loaded.
//
////////////////////////////////////////////////////////////////////////////////


// returns the number of elements in a menu
int menu_size(struct MENU_ELEMENT *menu)
{
  int result = 0;
  
    while( menu->type != MENU_END )
    {
      result++;
      menu++;
    }
    
    return(result);
}

void button_list(struct MENU_ELEMENT *e)
{
  int file_n = 0;
  num_listfiles = 0;
  int i;
  
  char cwdbuf[FF_LFN_BUF] = {0};
  FRESULT fr;
  char const *p_dir;

  //DEBUG_STOP;

  mount_sd();
  
  if( cd_to_pak_dir(&oled0) )
    {
      unmount_sd();
      return;
    }

  f_chdrive("0:");
  fr = f_getcwd(cwdbuf, sizeof cwdbuf);

  if (FR_OK != fr)
    {
      printf("f_getcwd error: %s (%d)\n", FRESULT_str(fr), fr);
      unmount_sd();
      return;    f_chdrive("0:");
    }
  
  p_dir = cwdbuf;

  printf("Directory Listing: %s\n", p_dir);
  
  DIR dj;      /* Directory object */
  FILINFO fno; /* File information */

  memset(&dj, 0, sizeof dj);
  memset(&fno, 0, sizeof fno);

  fr = f_findfirst(&dj, &fno, p_dir, "*");

  if (FR_OK != fr)
    {
      printf("f_findfirst error: %s (%d)\n", FRESULT_str(fr), fr);
      unmount_sd();
      return;
    }
  
  while( (fr == FR_OK) && fno.fname[0] && (num_listfiles < MAX_LISTFILES) )
    { 
       if (fno.fattrib & AM_DIR)
	 {
	   // Directory, we gnore these
	 }
       else
	 {
	   char extension[40];
	   char name[80];
	   
	   // If the file has an extension of .opk then display it
	   // otherwise ignore.
	   extension[0] = '\0';
	   
	   if( sscanf(fno.fname, "%[^.].%s", name, extension) )
	     {
	       if( strcmp(extension, "opk") == 0 )
		 {
		   // Create a new menu element
		   // we also don't want to display anything before the offset
		   if( file_n >= file_offset )
		     {
		       // It is an opk file so display it
		       strncpy(&(names[num_listfiles][0]), fno.fname, MAX_NAME);
		       
		       //	display.println(&(names[nu);
		       listfiles[num_listfiles].text = &(names[num_listfiles][0]);
		       listfiles[num_listfiles].type = BUTTON_ELEMENT;
		       listfiles[num_listfiles].submenu = NULL;
		       listfiles[num_listfiles].function = button_select_file;
		       
		       num_listfiles++;
		     }
	   	   // Next file
		   file_n++;
		 }
	     }
	 }
       
      fr = f_findnext(&dj, &fno); /* Search for next item */
    }
  f_closedir(&dj);

  // terminate the menu
  listfiles[num_listfiles].text = "";
  listfiles[num_listfiles].type = MENU_END;
  listfiles[num_listfiles].submenu = NULL;
  listfiles[num_listfiles].function = button_select_file;


#if 1// We know how big the menu is now
  if( num_listfiles != 0 )
    {
      file_menu_size = num_listfiles;
    }
#endif

  // Button actions modified
  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_file_select;

  // Set up menu of file names
  current_menu = &(listfiles[0]);
  draw_menu(&oled0, current_menu, false);

  unmount_sd();
}

static void run_ls() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "";
  ls(arg1);
}
static void run_cat() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  FIL fil;
  FRESULT fr = f_open(&fil, arg1, FA_READ);
  if (FR_OK != fr) {
    printf("f_open error: %s (%d)\n", FRESULT_str(fr), fr);
    return;
  }
  char buf[256];
  while (f_gets(buf, sizeof buf, &fil)) {
    printf("%s", buf);
  }
  fr = f_close(&fil);
  if (FR_OK != fr) printf("f_open error: %s (%d)\n", FRESULT_str(fr), fr);
}
static void run_big_file_test() {
  const char *pcPathName = strtok(NULL, " ");
  if (!pcPathName) {
    printf("Missing argument\n");
    return;
  }
  const char *pcSize = strtok(NULL, " ");
  if (!pcSize) {
    printf("Missing argument\n");
    return;
  }
  size_t size = strtoul(pcSize, 0, 0);
  const char *pcSeed = strtok(NULL, " ");
  if (!pcSeed) {
    printf("Missing argument\n");
    return;
  }
  uint32_t seed = atoi(pcSeed);
  //big_file_test(pcPathName, size, seed);
}
static void del_node(const char *path) {
  FILINFO fno;
  char buff[256];
  /* Directory to be deleted */
  strlcpy(buff, path, sizeof(buff));
  /* Delete the directory */
  FRESULT fr = delete_node(buff, sizeof buff / sizeof buff[0], &fno);
  /* Check the result */
  if (fr) {
    printf("Failed to delete the directory %s. ", path);
    printf("%s error: %s (%d)\n", __func__, FRESULT_str(fr), fr);
  }
}
static void run_del_node() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  del_node(arg1);
}
static void run_cdef() {
  f_mkdir("/cdef");  // fake mountpoint
  //vCreateAndVerifyExampleFiles("/cdef");
}
static void run_swcwdt() { /*vStdioWithCWDTest("/cdef");*/ }
static void run_loop_swcwdt() {
  int cRxedChar = 0;
  do {
    del_node("/cdef");
    run_cdef();
    run_swcwdt();
    cRxedChar = getchar_timeout_us(0);
  } while (PICO_ERROR_TIMEOUT == cRxedChar);
}
static void run_start_logger() {
  logger_enabled = true;
  next_time = delayed_by_ms(get_absolute_time(), period);
}
static void run_stop_logger() { logger_enabled = false; }
static void run_help();

typedef void (*p_fn_t)();
typedef struct {
  char const *const command;
  p_fn_t const function;
  char const *const help;
} cmd_def_t;

static cmd_def_t cmds[] = {
			   {"setrtc", run_setrtc,
			    "setrtc <DD> <MM> <YY> <hh> <mm> <ss>:\n"
			    "  Set Real Time Clock\n"
			    "  Parameters: new date (DD MM YY) new time in 24-hour format "
			    "(hh mm ss)\n"
			    "\te.g.:setrtc 16 3 21 0 4 0"},
			   {"date", run_date, "date:\n Print current date and time"},
			   {"lliot", run_lliot,
			    "lliot <drive#>:\n !DESTRUCTIVE! Low Level I/O Driver Test\n"
			    "\te.g.: lliot 1"},
			   {"format", run_format,
			    "format [<drive#:>]:\n"
			    "  Creates an FAT/exFAT volume on the logical drive.\n"
			    "\te.g.: format 0:"},
			   {"mount", run_mount,
			    "mount [<drive#:>]:\n"
			    "  Register the work area of the volume\n"
			    "\te.g.: mount 0:"},
			   {"unmount", run_unmount,
			    "unmount <drive#:>:\n"
			    "  Unregister the work area of the volume"},
			   {"chdrive", run_chdrive,
			    "chdrive <drive#:>:\n"
			    "  Changes the current directory of the logical drive.\n"
			    "  <path> Specifies the directory to be set as current directory.\n"
			    "\te.g.: chdrive 1:"},
			   {"getfree", run_getfree,
			    "getfree [<drive#:>]:\n"
			    "  Print the free space on drive"},
			   {"cd", run_cd,
			    "cd <path>:\n"
			    "  Changes the current directory of the logical drive.\n"
			    "  <path> Specifies the directory to be set as current directory.\n"
			    "\te.g.: cd /dir1"},
			   {"mkdir", run_mkdir,
			    "mkdir <path>:\n"
			    "  Make a new directory.\n"
			    "  <path> Specifies the name of the directory to be created.\n"
			    "\te.g.: mkdir /dir1"},
			   {"del_node", run_del_node,
			    "del_node <path>:\n"
			    "  Remove directory and all of its contents.\n"
			    "  <path> Specifies the name of the directory to be deleted.\n"
			    "\te.g.: del_node /dir1"},
			   {"ls", run_ls, "ls:\n  List directory"},
			   {"cat", run_cat, "cat <filename>:\n  Type file contents"},
			   //    {"simple", simple, "simple:\n  Run simple FS tests"},
			   {"big_file_test", run_big_file_test,
			    "big_file_test <pathname> <size in bytes> <seed>:\n"
			    " Writes random data to file <pathname>.\n"
			    " <size in bytes> must be multiple of 512.\n"
			    "\te.g.: big_file_test bf 1048576 1\n"
			    "\tor: big_file_test big3G-3 0xC0000000 3"},
			   {"cdef", run_cdef,
			    "cdef:\n  Create Disk and Example Files\n"
			    "  Expects card to be already formatted and mounted"},
			   {"swcwdt", run_swcwdt,
			    "\nswcwdt:\n Stdio With CWD Test\n"
			    "Expects card to be already formatted and mounted.\n"
			    "Note: run cdef first!"},
			   {"loop_swcwdt", run_loop_swcwdt,
			    "\nloop_swcwdt:\n Run Create Disk and Example Files and Stdio With CWD "
			    "Test in a loop.\n"
			    "Expects card to be already formatted and mounted.\n"
			    "Note: Type any key to quit."},
			   {"start_logger", run_start_logger,
			    "start_logger:\n"
			    "  Start Data Log Demo"},
			   {"stop_logger", run_stop_logger,
			    "stop_logger:\n"
			    "  Stop Data Log Demo"},
			   {"help", run_help,
			    "help:\n"
			    "  Shows this command help."}};
static void run_help() {
  for (size_t i = 0; i < count_of(cmds); ++i) {
    printf("%s\n\n", cmds[i].help);
  }
}

static void process_stdio(int cRxedChar) {
  static char cmd[256];
  static size_t ix;

  if (!isprint(cRxedChar) && !isspace(cRxedChar) && '\r' != cRxedChar &&
      '\b' != cRxedChar && cRxedChar != (char)127)
    return;
  printf("%c", cRxedChar);  // echo
  stdio_flush();
  if (cRxedChar == '\r') {
    /* Just to space the output from the input. */
    printf("%c", '\n');
    stdio_flush();

    if (!strnlen(cmd, sizeof cmd)) {  // Empty input
      printf("> ");
      stdio_flush();
      return;
    }
    /* Process the input string received prior to the newline. */
    char *cmdn = strtok(cmd, " ");
    if (cmdn) {
      size_t i;
      for (i = 0; i < count_of(cmds); ++i) {
	if (0 == strcmp(cmds[i].command, cmdn)) {
	  (*cmds[i].function)();
	  break;
	}
      }
      if (count_of(cmds) == i) printf("Command \"%s\" not found\n", cmdn);
    }
    ix = 0;
    memset(cmd, 0, sizeof cmd);
    printf("\n> ");
    stdio_flush();
  } else {  // Not newline
    if (cRxedChar == '\b' || cRxedChar == (char)127) {
      /* Backspace was pressed.  Erase the last character
	 in the string - if any. */
      if (ix > 0) {
	ix--;
	cmd[ix] = '\0';
      }
    } else {
      /* A character was entered.  Add it to the string
	 entered so far.  When a \n is entered the complete
	 string will be passed to the command interpreter. */
      if (ix < sizeof cmd - 1) {
	cmd[ix] = cRxedChar;
	ix++;
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// Menu system
//
typedef void (*FPTR)();
typedef void (*CMD_FPTR)(char *cmd);


// Debounce
#define MAX_BUT_COUNT 6

struct MENU_ELEMENT listfiles[MAX_LISTFILES+1];
int num_listfiles;
char names[MAX_LISTFILES][MAX_NAME];
char current_file[MAX_NAME+1];

int cd_to_pak_dir(I2C_SLAVE_DESC *slave)
{
  char line[40];
  FRESULT fr;
  char cwdbuf[FF_LFN_BUF] = {0};
  char const *p_dir;

  //DEBUG_STOP

  f_chdrive("0:");

#if 0
  // Are we in the pak directory already?
  fr = f_getcwd(cwdbuf, sizeof cwdbuf);
  if (FR_OK != fr)
    {
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      sprintf(line, "cwd error");
      oled_display_string(slave, line);

      oled_set_xy(slave, 0, 8);
      sprintf(line, "cwd:'%s'", cwdbuf);
      oled_display_string(slave, line);
      
      return;
    }

  if( strcmp(cwdbuf, PAK_DIR) != 0 )
    {
#endif
      
      // Change to the PAK directory
      fr = f_chdir(PAK_DIR);
      if (FR_OK != fr)
	{
	  oled_clear_display(slave);
	  oled_set_xy(slave, 0, 0);
	  sprintf(line, "Error opening");
	  oled_display_string(slave, line);
	  
	  oled_set_xy(slave, 0, 8);
	  sprintf(line, "directory");
	  oled_display_string(slave, line);
	  
	  oled_set_xy(slave, 0, 16);
	  sprintf(line, PAK_DIR);
	  oled_display_string(slave, line);
	  loop_delay(3000000);      
	  return(1);
	}
#if 0      
    }
#endif
  return(0);
}

////////////////////////////////////////////////////////////////////////////////
//
// Read and process the config file
//
////////////////////////////////////////////////////////////////////////////////

void process_config_file(I2C_SLAVE_DESC *slave)
{
  char line[40];
  char fileline[80];

  //DEBUG_STOP;
  
  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }
  
  oled_clear_display(slave);
  oled_set_xy(slave, 0, 0);
  sprintf(line, "Processing");
  oled_display_string(slave, line);
      
  oled_set_xy(slave, 0, 8);
  sprintf(line, "config.txt");
  oled_display_string(slave, line);
  
  loop_delay(1000000);

  // Read the file from the SD card into the pak memory
  FF_FILE *fp = ff_fopen("config.txt", "r");

  if (fp == NULL)
    {
      sprintf(line, "Failed to open:");
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      oled_display_string(slave, line);
      
      oled_set_xy(slave, 0, 7);
      sprintf(line, "config.txt");
      oled_display_string(slave, line);

      loop_delay(3000000);
      unmount_sd();
      return;
    }

  // Get a line from the file
  ff_fgets(&(fileline[0]), sizeof(fileline)-1, fp);
  fileline[strlen(fileline)-1] = '\0';

  ff_fclose(fp);
  unmount_sd();

  char keyword[80];
  char name[80];

  sscanf(fileline, "%[^=]=%s", keyword, name);
  if( strcmp(keyword, "startfile") == 0 )
    {
      strcpy(current_file, name);

      // read the file
      core_read(&oled0, current_file);
    }
}

// Read the file with the given name into the buffer
// Pak images are in a directory called PAK

void core_read(I2C_SLAVE_DESC *slave, char * arg)
{
  char line[40];

  //DEBUG_STOP;

  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }
  
  oled_clear_display(slave);
  oled_set_xy(slave, 0, 0);
  sprintf(line, "Reading file");
  oled_display_string(slave, line);
      
  oled_set_xy(slave, 0, 8);
  sprintf(line, "%s", arg);
  oled_display_string(slave, line);
  
  loop_delay(1000000);

  // Read the file from the SD card into the pak memory
  FIL fil;
  FRESULT fr = f_open(&fil, arg, FA_READ);

  if (FR_OK != fr)
    {
      sprintf(line, "Failed to open:");
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      oled_display_string(slave, line);
      
      oled_set_xy(slave, 0, 7);
      sprintf(line, "%s", arg);
      oled_display_string(slave, line);

      loop_delay(3000000);
      unmount_sd();
      return;
    }
  
  char buf[1];
  int pak_i = 0;
  int br = 0;
  bool done = false;
  char name[80];
  char extension[20];
  bool modify_header = false;
  
  // If the extension is .opk then we drop the first 6 bytes
  if( sscanf(arg, "%[^.].%s", name, extension) == 2 )
    {
      if( strcmp(extension, "opk") == 0 )
	{
	  // Drop 6 bytes from start of file
	  for(int i=0; i<6; i++)
	    {
	      f_read(&fil, buf, sizeof buf, &br);
	    }

	  // We need to modify the header, so set flag telling us to do
	  // that later
	  modify_header = true;
	}
    }
  
  while( !done )
    {
      f_read(&fil, buf, sizeof buf, &br);
      
      if( br == 0 )
	{
	  done = true;
	  continue;
	}
      
      for(int i=0; i<br; i++)
	{
	  pak_memory[pak_i++] = buf[i];
	}
    }
  f_close(&fil);
  
  oled_set_xy(slave, 0, 16);
  sprintf(line, "%d bytes read", pak_i);
  oled_display_string(slave, line);

  if( modify_header )
    {
      pak_memory[0] = 0x78;
      pak_memory[1] = 0x04; //64K, could allow original length through
      pak_memory[2] = 0x56;
      pak_memory[3] = 0x00;
      pak_memory[4] = 0x03;
      pak_memory[5] = 0x02;
      pak_memory[6] = 0x35;
      pak_memory[7] = 0x46;
      pak_memory[8] = 0x06;
      pak_memory[9] = 0x4c;
      
    }
  
  loop_delay(3000000);
  unmount_sd();
}

// Writes the buffer to a file.
// Deletes any file that exists with the same name so that the resulting
// file is the same size as the buffer
// Searches the card directory for the highest file number and uses the next one
//

void core_writefile(bool oled_nserial)
{
  char filename[20];
  int i;
  FRESULT fr;
  FIL fp;
  int bytes_written = 0;
  char line[40];

  //DEBUG_STOP

  mount_sd();
  
  if( cd_to_pak_dir(&oled0) )
    {
      unmount_sd();
      return;
    }

  find_next_file_number();
  sprintf(filename, PAK_FILE_NAME_FORMAT, ++max_filenum);
  
  oled_clear_display(&oled0);
  oled_set_xy(&oled0, 0, 0);
  oled_display_string(&oled0, "Writing");
  oled_set_xy(&oled0, 0, 8);
  oled_display_string(&oled0, filename);
  
  // Open file for writing
  fr = f_open(&fp, filename, FA_CREATE_NEW | FA_WRITE);

  if (FR_OK != fr && FR_EXIST != fr)
    {
      oled_error("Open error");
      unmount_sd();
      return;
    }

  // As we are writing an OPK file, we add a header in the first 6 bytes. We don't
  BYTE hdr[6] = {'O', 'P', 'K', 0, 0, 0};

  f_write (&fp, &(hdr[0]), 6, &bytes_written);
  
  // Write the entire buffer in one go
  f_write (&fp, &(pak_memory[0]), PAK_MEMORY_SIZE, &bytes_written);

  bytes_written += 6;
  
  fr = f_close(&fp);
  if (FR_OK != fr)
    {
      printf("f_close error: %s (%d)\n", FRESULT_str(fr), fr);
      unmount_sd();
      return false;
    }

  oled_set_xy(&oled0, 0, 3*8);
  sprintf(line, "%d bytes", bytes_written);
  oled_display_string(&oled0, line);

  unmount_sd();

}

// The switch menu/OLED display system
void to_back_menu(struct MENU_ELEMENT *e)
{
  menu_selection = 0;
  menu_offset = 0;
  current_menu = last_menu;
  draw_menu(&oled0, current_menu, true);
}

void to_home_menu(struct MENU_ELEMENT *e)
{
  menu_selection = 0;
  menu_offset = 0;
  current_menu = the_home_menu;
  draw_menu(&oled0, current_menu, true);
}

void button_clear(struct MENU_ELEMENT *e)
{
  loop_delay(3000000);
  draw_menu(&oled0, current_menu, true);
}

void button_write(struct MENU_ELEMENT *e)
{
  core_writefile(true);

  loop_delay(3000000);
  draw_menu(&oled0, current_menu, true);
}


// The button function puts up to the first 7 files on screen then set sup a button handler
// which will display subsequent pages.
// We use the menu structures to display the names and allow selection

// File selected
void button_select_file(struct MENU_ELEMENT *e)
{
}

//--------------------------------------------------------------------------------

// Move up in a menu

void but_ev_up()
{
  // Move up one place
  menu_selection--;

  // Keep within bounds
  if( menu_selection <= 0 )
    {
      menu_selection = 0;
    }

  // Now move offset up if it is greter than selection
  if( menu_offset > menu_selection )
    {
      menu_offset = menu_selection;
    }
  
  draw_menu(&oled0, current_menu, false);
}

void but_ev_down()
{
  // Move cursor down one entry
  menu_selection++;

  // Are we off the end of the menu?
  if( menu_selection == menu_size(current_menu) )
    {
      // At last element of menu
      menu_selection--;
    }

  // Do we need to pull the top element down?
  if( (menu_selection - menu_offset) >= MENU_MAX )
    {
      menu_offset = menu_selection - MENU_MAX+1;
      if( menu_offset < 0 )
	{
	  menu_offset = 0;
	}
    }
  
  draw_menu(&oled0, current_menu, false);
  //  button_list(NULL);
}

// Store file name and exit menu
// File can be read later

void but_ev_file_select()
{
  char line[40];
  
  strcpy(current_file, listfiles[menu_selection].text);
  file_offset = 0;

  oled_clear_display(&oled0);
  oled_set_xy(&oled0, 0,0);
  sprintf(line, "Selected File:");
  oled_display_string(&oled0, line);

  oled_set_xy(&oled0, 0,14);
  sprintf(line, "%s", current_file);
  oled_display_string(&oled0, line);

  loop_delay(3000000);

  // As well as selecting the file, read in in to the buffer as well
  core_read(&oled0, current_file);

  menu_selection = 0;
  to_home_menu(NULL);
  
  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_select;
}

void button_to_home(struct MENU_ELEMENT *e)
{
  to_home_menu(NULL);
}

// Get a list of the files on the SD card and display
// them so one can be selected.

void button_list_old(struct MENU_ELEMENT *e)
{
#if 0
  File dir;
  int file_n = 0;
  num_listfiles = 0;
  int i;

  dir = SD.open("/");

  // return to the first file in the directory
  dir.rewindDirectory();
  
  while (num_listfiles < MAX_LISTFILES) {

    File entry =  dir.openNextFile();

    if (! entry) {
      // no more files
      // terminate menu
      listfiles[num_listfiles].text = "";
      listfiles[num_listfiles].type = MENU_END;
      listfiles[num_listfiles].submenu = NULL;
      listfiles[num_listfiles].function = button_select_file;
      entry.close();
      break;
    }

    
    // We don't allow directories and don't ount them
    if (entry.isDirectory())
      {
      }
    else
      {
#if DEBUG	
	Serial.print("BList-file_n:");
	Serial.print(file_n);
	Serial.print(entry.name());
	Serial.print("  num_listfiles:");
	Serial.println(num_listfiles);
#endif
	// Create a new menu element
	// we also don't want to display anything before the offset
	if( file_n >= file_offset )
	  {
	    strncpy(&(names[num_listfiles][0]), entry.name(), MAX_NAME);
	    //	display.println(&(names[nu);
	    listfiles[num_listfiles].text = &(names[num_listfiles][0]);
	    listfiles[num_listfiles].type = BUTTON_ELEMENT;
	    listfiles[num_listfiles].submenu = NULL;
	    listfiles[num_listfiles].function = button_select_file;
	    
	    num_listfiles++;
	  }
	// Next file
	file_n++;

      }
    entry.close();
    
  }

  dir.close();

  // terminate menu
  listfiles[num_listfiles].text = "";
  listfiles[num_listfiles].type = MENU_END;
  listfiles[num_listfiles].submenu = NULL;
  listfiles[num_listfiles].function = button_select_file;

  // We know how big the menu is now
#if 0
  if( num_listfiles != 0 )
    {
      menu_size = num_listfiles;
    }
#endif
  
  // Button actions modified
  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_file_select;

  // Set up menu of file names
  current_menu = &(listfiles[0]);
  draw_menu(&oled0, current_menu, false);
#endif
}


#define COLUMNS 5
#define PAGE_LENGTH 30

// Display the buffer

int display_offset = 0;

void but_page_up()
{
  if( display_offset > PAGE_LENGTH )
    {
      display_offset -= PAGE_LENGTH;
    }
  else
    {
      display_offset = 0;
    }
  button_display(NULL);
}

void but_page_down()
{
#if 0
  display_offset += PAGE_LENGTH;
  
  if( display_offset >= bytecount )
    {
      display_offset = bytecount-PAGE_LENGTH;
    }

  if( display_offset < 0 )
    {
      display_offset = 0;
    }
  
  button_display(NULL);
#endif
}

void but_page_exit()
{
  display_offset = 0;
  draw_menu(&oled0,current_menu, true);

  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_select;

}

void button_display(struct MENU_ELEMENT *e)
{
#if 0
  int i;
  char ascii[17];
  char c[5];
  
  int ascii_i = 0;

  oled_clear_display(&oled0);
  
  //display.clearDisplay();
  
  for(i=0; (i<bytecount) && (i<PAGE_LENGTH); i++)
    {
      if( isprint(stored_bytes[i]) )
	{
	  sprintf(ascii, "%c", stored_bytes[i+display_offset]);
	}
      else
	{
	  sprintf(ascii, ".");
	}
      
      sprintf(c,     "%02X",  stored_bytes[i+display_offset]);

#if 0
      display.setCursor(6*15+(i%COLUMNS)*1*6, 8*(i/COLUMNS+1));
      display.println(ascii);
      display.setCursor(10*0+(i%COLUMNS)*2*8, 8*(i/COLUMNS+1));
      display.print(c);
#endif
    }

  // Drop into page up and down and exit buttoin handlers
  buttons[0].event_fn = but_page_up;
  buttons[1].event_fn = but_page_down;
  buttons[2].event_fn = but_page_exit;

  //display.display();
#endif
}


void button_exit(struct MENU_ELEMENT *e)
{
  menuloop_done = 1;
}

void button_send(struct MENU_ELEMENT *e)
{
  //send_databytes(true);
  draw_menu(&oled0, current_menu, true);
}

////////////////////////////////////////////////////////////////////////////////
//
//  Read the current file from SD card into the pak memory

void button_read(struct MENU_ELEMENT *e)
{
  core_read(&oled0, current_file);

  draw_menu(&oled0, current_menu, true);
}

////////////////////////////////////////////////////////////////////////////////
//
// Blanks the pak memory which will enable it to be sized
//
// Probably need an 'Are you sure?'
//
////////////////////////////////////////////////////////////////////////////////

void button_blank(struct MENU_ELEMENT *e)
{
  char line[40];
  
  for(int k=0; k< 100; k++)
    {
      pak_memory[k] = 0xff;
    }

  oled_clear_display(&oled0);
  oled_set_xy(&oled0, 0, 0);
  sprintf(line, "Buffer Cleared");
  oled_display_string(&oled0, line);

  loop_delay(3000000);
  
  draw_menu(&oled0, current_menu, true);
}


struct MENU_ELEMENT home_menu[] =
  {
   {BUTTON_ELEMENT, "List",                       NULL,     button_list},
   {BUTTON_ELEMENT, "Clear",                      NULL,     button_clear},
   {BUTTON_ELEMENT, "Write",                      NULL,     button_write},
   {BUTTON_ELEMENT, "Display",                    NULL,     button_display},
   {BUTTON_ELEMENT, "Blank",                      NULL,     button_blank},
   {BUTTON_ELEMENT, "Read",                       NULL,     button_read},
   {BUTTON_ELEMENT, "Exit",                       NULL,     button_exit},
   {MENU_END,       "",                           NULL,     NULL},
  };

// Clear flag indicates whether we redraw the menu text and clear the screen. Or not.
//
// Menus are displayed starting at menu_offset and will only put
// MENU_MAX lines on the screen
// This allows eithee size of display to be used

void draw_menu(I2C_SLAVE_DESC *slave, struct MENU_ELEMENT *e, bool clear)
{
  int i = 0;
  char etext[50];

  e = current_menu;

  //DEBUG_STOP
  
  // Clear screen
  if(clear,1)
    {
      oled_clear_display(slave);
      //display.clearDisplay();
    }

  int entry_number = -1;
  
  while( e->type != MENU_END )
    {
      entry_number++;
      
      // Skip the first menu_offset entries
      if( entry_number < menu_offset )
	{
	  e++;
	  continue;
	}

      // Don't ever display more than MENU_MAX elements
      if( (entry_number - menu_offset) > MENU_MAX )
	{
	  break;
	}

      if( entry_number == menu_selection )
	{
	  sprintf(etext, ">%-19s", e->text);
	}
      else
	{
	  sprintf(etext, " %-19s", e->text);
	}
      
      switch(e->type)
	{
	case BUTTON_ELEMENT:
	  oled_set_xy(slave, 0, i*8);
	  //display.printChar(curs);
	  if( clear,1 )
	    {
	      oled_display_string(slave, etext);
	    }
	  break;

	case SUB_MENU:
	  oled_set_xy(slave, 0, i*8);
	  //	  display.setCursor(0, i*8);
	  //display.printChar(curs);
	  if ( clear,1 )
	    {
	      oled_display_string(slave, etext);
	      //	      display.println(etext);
	    }
	  break;
	}

      e++;
      i++;
    }
  
  //menu_size = i;

  // Blank the other entries
  //make sure menu_selection isn't outside the menu
  if( menu_selection >= menu_size(current_menu) )
    {
      menu_selection = menu_size(current_menu)-1;
    }

  for(; i<MENU_MAX; i++)
    {
      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, "               ");
      //      display.setCursor(0, i*8);
      //display.println("               ");
    }

#if 0  
  for(i=menu_offset; i<menu_offset+MENU_MAX-1;i++)
    {
      if( i == menu_selection )
	{
	  curs = ">";	  
	}
      else
	{
	  curs = " ";
	}

      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, curs);

      //display.setCursor(0, i*8);
      //display.print(curs);
    }
#endif  
#if 0
  char line[40];
  oled_set_xy(slave, 0, 8);
  sprintf(line, "%d %d %d %d  ", menu_selection, menu_offset, menu_size(current_menu), file_menu_size);
  oled_display_string(slave, line);
#endif
}

void old_draw_menu(I2C_SLAVE_DESC *slave, struct MENU_ELEMENT *e, bool clear)
{
  int i = 0;
  char *curs = " ";
  char etext[20];

  //DEBUG_STOP
  
  // Clear screen
  if(clear,1)
    {
      oled_clear_display(slave);
      //display.clearDisplay();
    }
  
  while( e->type != MENU_END )
    {
      sprintf(etext, " %-19s", e->text);
      
      switch(e->type)
	{
	case BUTTON_ELEMENT:
	  oled_set_xy(slave, 0, i*8);
	  //display.printChar(curs);
	  if( clear,1 )
	    {
	      oled_display_string(slave, etext);
	    }
	  break;

	case SUB_MENU:
	  oled_set_xy(slave, 0, i*8);
	  //	  display.setCursor(0, i*8);
	  //display.printChar(curs);
	  if ( clear,1 )
	    {
	      oled_display_string(slave, etext);
	      //	      display.println(etext);
	    }
	  break;
	}
      e++;
      i++;
    }
  
  //menu_size = i;

  // Blank the other entries
  //make sure menu_selection isn't outside the menu
  if( menu_selection >= menu_size(current_menu) )
    {
      menu_selection = menu_size(current_menu)-1;
    }

  for(; i<MAX_LISTFILES; i++)
    {
      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, "               ");
      //      display.setCursor(0, i*8);
      //display.println("               ");
    }

  for(i=0;i<menu_size(current_menu);i++)
    {
      if( i == menu_selection )
	{
	  curs = ">";	  
	}
      else
	{
	  curs = " ";
	}

      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, curs);

      //display.setCursor(0, i*8);
      //display.print(curs);
    }
}

// Null button event function
void but_ev_null()
{ 
}

void old_but_ev_up()
{
  if( menu_selection == 0 )
    {
      menu_selection = menu_size(current_menu) - 1;
    }
  else
    {
      menu_selection = (menu_selection - 1) % menu_size(current_menu);
    }
  
  draw_menu(&oled0, current_menu, false);
}

void old_but_ev_down()
{

  //DEBUG_STOP

  menu_selection = (menu_selection + 1) % menu_size(current_menu);

  draw_menu(&oled0, current_menu, false);
}

void but_ev_select()
{
  struct MENU_ELEMENT *e;
  int i = 0;
  
  // Do what the current selection says to do
  for(e=current_menu, i=0; (e->type != MENU_END); i++, e++)
    {
      if( i == menu_selection )
	{
	  switch(e->type)
	    {
	    case SUB_MENU:
	      current_menu = (struct MENU_ELEMENT *)e->submenu;
	      draw_menu(&oled0, current_menu, true);
	      break;
	      
	    default:
	      // Do action
	      (e->function)(e);
	      break;
	    }
	}
    }
}


void init_buttons()
{
  for(int i=0; i<NUM_BUTTONS; i++)
    {
      buttons[i].count = 0;
      buttons[i].pressed = false;
      buttons[i].last_pressed = false;
      buttons[i].event_fn = but_ev_null;
    }

  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_select;
}

void update_buttons()
{
  for(int i=0; i<NUM_BUTTONS; i++)
    {
      if( gpio_get(but_pins[i]) == 0 )
	{
	  if( buttons[i].count < MAX_BUT_COUNT )
	    {
	      buttons[i].count++;
	      if( buttons[i].count == MAX_BUT_COUNT )
		{
		  // Just got to MAX_COUNT
		  buttons[i].pressed = true;
		}
	    }
	}
      else
	{
	  if( buttons[i].count > 0 )
	    {
	      buttons[i].count--;
	      
	      if( buttons[i].count == 0 )
		{
		  // Just got to zero
		  buttons[i].pressed = false;
		}
	    }
	}
      
      // If button has gone from pressed to not pressed then we treat that as a key event
      if( (buttons[i].last_pressed == true) && (buttons[i].pressed == false) )
	{
	  (buttons[i].event_fn)();
	}

      buttons[i].last_pressed = buttons[i].pressed;
    }
}

////////////////////////////////////////////////////////////////////////////////

// read the value on the data bus

int data_gpio[8] =
  {
   SLOT_SD0_PIN,
   SLOT_SD1_PIN,
   SLOT_SD2_PIN,
   SLOT_SD3_PIN,
   SLOT_SD4_PIN,
   SLOT_SD5_PIN,
   SLOT_SD6_PIN,
   SLOT_SD7_PIN,
  };

//------------------------------------------------------------------------------
//
// Get value on data lines
//

inline BYTE get_data(void)
{
  int data = 0;

#if !USE_OE_FOR_DATA_DIRECTION
  // As we are reading the bus, the direction line should be high
  gpio_put(LS_DIR_PIN, 1);
#endif
  
  // Data is GPIO0..7
  // Direct register access, as it's faster
  data = sio_hw->gpio_in;
  data >>= 0;
  data &= 0xff;

  return((BYTE)data);
}

//-----------------------------------------------------------------------------
//
// Set data bus to drive us

inline void set_data_inputs(void)
{

  // GPIO0..7 is data
  sio_hw->gpio_oe_clr = 0x000000FF;

#if !USE_OE_FOR_DATA_DIRECTION
  // Drive level shifters to be driving Pico
  gpio_put(LS_DIR_PIN, 1);
#endif
}

inline void set_data_outputs(void)
{

  // GPIO0..7 is data
  sio_hw->gpio_oe_set = 0x000000FF;

#if !USE_OE_FOR_DATA_DIRECTION
  // Drive level shifters to be driving Pico
  gpio_put(LS_DIR_PIN, 1);
#endif
}

// Set up the data bus GPIO lines

inline void set_data_bus(BYTE data)
{
#if DIRECT_GPIO
  int states;
  int dat = data & 0xff;
  //dat = ss_address;
  
  // Direct register access to make things faster
#if 0
  // Get current output states
  states = sio_hw->gpio_out;

  // Our data has its LSB at GPIO8
  states &= 0xFFFF00FF;
  sio_hw->gpio_out = states | (dat <<8);
#else
  sio_hw->gpio_set = (  dat  << 8);
  sio_hw->gpio_clr = ((dat ^ 0xFF) << 8);
    
#endif
  
#else
  int i;

  // Ensure the level shifters are towards the Psion, and we are set as ouputs
  for(i=0; i<8; i++)
    {
      if( data & (1 << i) )
	{
	  gpio_put(data_gpio[i], 1);
	}
      else
	{
	  gpio_put(data_gpio[i], 0);
	}
    }
#endif
}

//-----------------------------------------------------------------------------
//
// Put a value on the data bus

inline void set_data(BYTE data)
{
  int states;
  int dat = data & 0xff;
  
  // Direct register access to make things faster
  sio_hw->gpio_set = (  dat  << 0);
  sio_hw->gpio_clr = ((dat ^ 0xFF) << 0);
}

////////////////////////////////////////////////////////////////////////////////
//
// Poll and handle the address counter on the second core
//

void handle_address(void)
{
  int last_ss;
  int last_sclk;
  int last_soe;
  int last_smr;
  int last_spgm;
  
  last_ss     = gpio_get(SLOT_SS_PIN);
  last_sclk   = gpio_get(SLOT_SCLK_PIN);
  last_soe    = gpio_get(SLOT_SOE_PIN);
  last_smr    = gpio_get(SLOT_SMR_PIN);
  last_spgm   = gpio_get(SLOT_SPGM_PIN);

  int ss;
  int sclk;
  int soe;
  int smr;
  int spgm;

  TRACE('I');
  TRACE('N');
  TRACE('I');
  TRACE('T');

  while(1)
    {
      // Read GPIO states
      ss     = gpio_get(SLOT_SS_PIN);
      sclk   = gpio_get(SLOT_SCLK_PIN);
      soe    = gpio_get(SLOT_SOE_PIN);
      smr    = gpio_get(SLOT_SMR_PIN);
      spgm   = gpio_get(SLOT_SPGM_PIN);
      
      //----------------------------------------------------------------------
      // SCLK handling
      // The lower address bit is the CLK line
      // Falling edge
      if( (last_sclk == 1) && (sclk == 0))
	{
	  // Only increment if the SMR line is low
	  if( smr == 0 )
	    {
	      TRACE('c');
	      ss_address+=2;
	      ss_address &= (~1);
	      
	      // Wrap address
	      ss_address &= PAK_MEMORY_SIZE - 1;
	      
	      TRACE(ss_address & 0xFF);
	      TRACE((ss_address >> 8) & 0xFF);
	    }
	  else
	    {
	      // Trace 'clock when SMR high', this is seen in traces
	      TRACE('z');
	    }
	}
      
      // Rising edge
      if( (last_sclk == 0) && (sclk == 1))
	{
	  if( smr == 0 )
	    {
	      ss_address |= 1;
	      TRACE('C');
	      TRACE(ss_address & 0xFF);
	      TRACE((ss_address >> 8) & 0xFF);
	    }
	  else
	    {
	      TRACE('Z');
	    }
	}

      // We now have to present data if we are selected
      if( ss == 0 )
	{
	  // We are selected, look at SOE to see if we should drive the data bus or not
	  if ( soe )
	    {
	      int data;
	      
	      // High so don't drive the data bus, this is a write
	      // Capture data on bus
	      set_bus_inputs();
	      
	      // We don't write here as SS hasn't gone high and OE hasn't gone high
	      data = get_data_bus();

#if !READ_ONLY		  
	      if( smr == 0 )
		{
		  // write to ram
		  WRITE_TRAP;
		  pak_memory[PAK_ADDRESS] = data;
		}
#endif
	    }
	  else
	    {
	      // Low, so this is a read
	      // Is it a read of the pak ID?
	      if( smr && spgm )
		{
		  TRACE('i');
		  
		  // ID byte
		  set_bus_outputs();
		  set_data_bus(1);
		}
	      else
		{
		  // Read of pak memory
		  set_bus_outputs();
		  set_data_bus(pak_memory[PAK_ADDRESS]);
		}
	    }
	  
	}

      //--------------------------------------------------------------------------------
      // Page Counter

      if( (last_spgm == 1) && (spgm == 0) )
	{
	  TRACE('P');
	  ss_page += (1 << 8);
	  ss_page &= 0x00007F00;
	}
      
      //----------------------------------------------------------------------
      // SMR handling
      
      if( (last_smr == 0) && (smr == 1) )
	{
	  TRACE('R');
	  TRACE('E');
	  TRACE('S');
	  
	  ss_address=0;
	  ss_page = 0;
	}

      last_ss     = ss;
      last_sclk   = sclk;
      last_soe    = soe;
      last_smr    = smr;
      last_spgm   = spgm;

    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Set things up then sit in a loop waiting for the emulated devcie to
// be selected
//
////////////////////////////////////////////////////////////////////////////////

#define MAX_ADDR_TRACE 256


int main()
{
  int addr_trace_index = 0;
  volatile uint32_t addr_trace[MAX_ADDR_TRACE];
  int trace_on = 0;
  
  // Set up test program
  rom_data[MAP_ROM(0xFFFC)] = 0x00;
  rom_data[MAP_ROM(0xFFFD)] = 0xF8;

  rom_data[MAP_ROM(0xF800)] = 0x4C;
  rom_data[MAP_ROM(0xF801)] = 0x00;
  rom_data[MAP_ROM(0xF802)] = 0xF8;
    
  //DEBUG_STOP;
  
  char line[80];

  // Set up default file name, default is angling pak
  strcpy(current_file, "angler.opk");
  
  stdio_init_all();

  printf("\nPico ROM Emulator\n");
  
#if TEST_STDIO
  {
  int count;
  while (true)
    {
      count++;
      
      if( (count % 1000000) == 0 )
	{
	  sprintf(line, "\nRP2040: %d", count);
	  printf(line);
	}
    }
  }
#endif

  printf("\nSetting GPIOs...");

  for (int i=0; i<NUM_ADDR; i++)
    {
      // Set up directions for the control lines
      gpio_init(address_pins[i]);
      gpio_set_dir(address_pins[i], GPIO_IN);
    }

  for (int i=0; i<NUM_DATA; i++)
    {
      // Set up directions for the control lines
      gpio_init(data_pins[i]);
      gpio_set_dir(data_pins[i], GPIO_OUT);
    }

  gpio_init(OE_PIN);
  gpio_set_dir(OE_PIN, GPIO_IN);
  gpio_init(CE_PIN);
  gpio_set_dir(CE_PIN, GPIO_IN);

  // DEBUG: Use DDIR_A15 as status line
  gpio_init(DDIR_A15_PIN);
  gpio_set_dir(DDIR_A15_PIN, GPIO_OUT);

  //set_data_outputs();
#if 0
#if !USE_OE_FOR_DATA_DIRECTION


  // LS_DIR is an output
  gpio_set_dir(LS_DIR_PIN, GPIO_OUT);
#else
  gpio_put(DDIR_A15_PIN, 0);
  gpio_set_dir(DDIR_A15_PIN, GPIO_OUT);
#endif
#endif
  

  // Use a polling loop for minimum latency
#if 0
  // Turn off timer interrupts
  irq_set_mask_enabled(0xf, false);
#endif
  
  // We set the CE of the level shifters to be driven by OE on the
  // host board, and the direction (A->B) to be set up by the Pico
  // The data direction can be left as output from the Pico as
  // the OE/CE line will drive on to the data bus when OE is asserted
  volatile unsigned int number_ce_assert = 0;
  
  while(1)
    {
      uint32_t gpio_states;
      BYTE db;
      unsigned int addr;

      gpio_put(DDIR_A15_PIN, 1);
      gpio_put(DDIR_A15_PIN, 1);
      gpio_put(DDIR_A15_PIN, 1);
      gpio_put(DDIR_A15_PIN, 1);
      gpio_put(DDIR_A15_PIN, 0);
      
      // read GPIOs
      gpio_states = sio_hw->gpio_in;

      // We look for CE
      if( gpio_states & (1 << CE_PIN),0 )
	{
	  // CE high, we are not selected
	}
      else
	{
	  // CE low, we are selected
	  // ROM emulation so always a read of us
	  // get address
	  addr = (gpio_states >> 8) & ADDRESS_MASK;

	  // Get data and present it on bus
	  set_data(rom_data[addr]);

	  // Trace address
	  if( addr == 0x07fc )
	    {
	      trace_on = 1;
	    }
	  
	  if( trace_on )
	    {
	      if( addr_trace_index < MAX_ADDR_TRACE )
		{
		  addr_trace[addr_trace_index] = addr | (rom_data[addr] << 16);
		  addr_trace_index++;
		  //addr_trace_index %= MAX_ADDR_TRACE;
		  
		}
	    }
    	  number_ce_assert++;

	  // Wait for CE to be de-asserted
	  while(1,0)
	    {
	      gpio_states = sio_hw->gpio_in;
	  
	      // We look for CE
	      if( gpio_states & (1 << CE_PIN) )
		{
		  // CE high, we are not selected
		  break;
		}
	      
	    }
	}

      gpio_put(DDIR_A15_PIN, 0);

    }
}



